{
    "collab_server" : "",
    "contents" : "# function to summarize statistics from a growing network \nGetStatistics <-\nfunction(data,net_type = c(\"directed\",\"undirected\"), only_PA = FALSE, Binning = TRUE, G = 200, start_deg = 0,  \n         deg_threshold = 0, CompressMode = c(0,1,2,3), CompressRatio = 0.5 , CustomTime = NULL, \n         only_true_deg_matrix = FALSE){\n\n    data              <- data[order(data[,3], decreasing = FALSE),]\n    time_stamp        <- as.vector(data[,3])\n    in_node           <- as.vector(data[,2])\n    out_node          <- as.vector(data[,1])\n    out_node          <- out_node[out_node != -1]\n    node_id           <- sort(union(in_node,out_node))\n   \n    if (net_type[1] == \"directed\") {\n        deg           <- table(in_node)\n    } else\n    if (net_type[1] == \"undirected\")\n        deg           <- table(c(in_node,out_node))     \n        #deg           <- table(as.vector(as.matrix(data[,1:2])))        \n    \n    deg_new           <- rep(0,length(node_id))\n    names(deg_new)    <- node_id\n    deg_new[labels(deg)[[1]]] <- deg\n    deg               <- deg_new\n    final_deg         <- deg\n    deg.max           <- as.numeric(max(deg))\n    if (start_deg >= deg.max)\n        stop(\"Starting degree too large!\") else \n    if (start_deg < 0)\n        stop(\"Negative starting degree!\")\n    unique_time       <- sort(unique(time_stamp))\n    T                 <- length(unique_time)\n    N                 <- length(node_id)\n    if (only_true_deg_matrix == TRUE)\n        Binning <- FALSE  \n    ##############  Binning #########################\n    #We have to cover from start_deg degree to deg.max degree, that is an interval with length deg.max - start_deg + 1\n    if ((TRUE == Binning) && (G > 0) && (G <= deg.max - start_deg + 1)) {\n        if (1 == G) {\n            base            <- deg.max - start_deg + 1\n            interval_length <- deg.max - start_deg + 1\n        } else {\n            #find the base that gives exactly G bin\n            is.warn <- options()$warn \n            options(warn = -1) #temporily supress warning\n            ff <- function(x){deg.max - start_deg + 1.0 - sum(floor(x^(0:(G - 1))))}\n            base      <- uniroot(ff,interval = c(1 + 1e-15,deg.max - start_deg + G + 1.1),tol = .Machine$double.eps)$root\n            options(warn = is.warn)\n            interval_length <- floor(base^(0:(G-1)))\n        }\n    } else if ((FALSE == Binning) || (0 == G) || (G > deg.max - start_deg + 1)) {\n        G               <- deg.max - start_deg + 1\n        interval_length <- rep(1,G)\n        base            <- 1\n    }\n    \n    bin_vector   <-rep(G + start_deg - 1, deg.max + 1)  # degree 0 to deg.max\n    # The right-end degree of the bins\n    begin_deg   <- c(start_deg,start_deg + cumsum(interval_length)[-G])\n    end_deg     <- begin_deg + interval_length - 1\n    if (start_deg > 0)\n        bin_vector[1:start_deg]  <- 0:(start_deg - 1)\n    for (i in 1:G) \n        bin_vector[(begin_deg[i]:end_deg[i]) + 1]  <- i + start_deg - 1\n    ########### Compress Time stamp #########################\n    \n    if (1 == CompressMode[1]) {\n        T_compressed           <- round(CompressRatio*(T - 1))\n        compressed_unique_time <- floor(seq(1,T - 1,length.out = T_compressed))\n    } else if (2 == CompressMode[1]){\n        edge_cumsum             <- cumsum(as.vector(table(time_stamp))) \n        edge_ratio              <- edge_cumsum/edge_cumsum[T]\n        compressed_unique_time  <- unique_time[which(edge_ratio >= 1 - CompressRatio)]\n        temp                    <- edge_ratio[which(edge_ratio < 1 - CompressRatio)]\n        CompressRatio           <- temp[length(temp)]\n        T_compressed            <- length(compressed_unique_time)\n    }  else if (3 == CompressMode[1]) {\n        compressed_unique_time <- sort(unique(CustomTime))\n        CompressRatio          <- length(compressed_unique_time)/(T - 1)\n    } else {\n        #No Time compression\n        CompressRatio   <- 1\n        T_compressed    <- T\n        compressed_unique_time <- unique_time\n    }\n    if (net_type[1] == \"directed\")\n        first_edge       <- table(in_node[time_stamp == unique_time[1]]) else \n    if (net_type[1] == \"undirected\")\n        first_edge       <- table(as.vector(as.matrix(data[time_stamp == unique_time[1],1:2])))\n       \n    first_deg        <- rep(0,N)\n    increase         <- rep(0,N)\n    names(increase)  <- node_id\n    names(first_deg) <- node_id\n    first_deg[labels(first_edge)[[1]]] <- first_edge\n    # this is not the true number of new edges, due to the first appearance of a node together with some edges\n    # but this can be used as an crude first step selection\n    # the accurate selection can be done after\n    inc              <- deg - first_deg  \n    increase         <- inc\n    initial_nodes    <- length(first_edge)\n    if (FALSE == only_PA) {\n        pos_temp          <- inc >= deg_threshold\n        if (sum(pos_temp) == 0)\n            stop(\"Degree threshold is too high. Please decrease degree threshold.\")  \n        f_position        <- node_id[pos_temp]\n    } else f_position        <- NULL\n    \n    node_id_old <- node_id\n    if (FALSE == only_PA)\n        node_id     <- node_id[inc >= deg_threshold]\n    \n    N_new            <- length(node_id) \n    degree_appear    <- rep(0,deg.max + 1)\n    if (only_true_deg_matrix == TRUE) {\n        Sum_m_k          <- vector() \n        n_tk             <- matrix(0,0,0)\n        m_tk             <- matrix(0,0,0)\n        m_t              <- vector() \n    } else {\n        Sum_m_k          <- rep(0,start_deg + G)\n        n_tk             <- matrix(0,nrow = T_compressed - 1, ncol = start_deg + G)\n        m_tk             <- matrix(0,nrow = T_compressed - 1, ncol = start_deg + G)\n        m_t              <- rep(0,T_compressed - 1)  \n    }\n\n    if (FALSE == only_PA) {\n        if (only_true_deg_matrix == FALSE)  {\n            offset_tk               <- matrix(0,nrow = T_compressed - 1, ncol = start_deg + G) \n            offset_m_tk             <- matrix(0,nrow = T_compressed - 1, ncol = start_deg + G) \n            z_j                     <- rep(0,N_new)\n        } else {\n          offset_tk               <- matrix(0,0,0)\n          offset_m_tk             <- matrix(0,0,0) \n          z_j                     <- vector()    \n        }\n        node_degree <- matrix(-1,nrow = T_compressed - 1, ncol = N_new) \n    } else {\n        offset_tk               <- matrix(0,0,0)\n        offset_m_tk             <- matrix(0,0,0) \n        z_j                     <- vector()  \n        node_degree             <- matrix(0,0,0)\n    }\n    undirected  = 0;\n    max_node_id = max(node_id_old);\n    only_PA_num = ifelse(only_PA,1,0);\n    only_true_deg_matrix_num = ifelse(only_true_deg_matrix,1,0)\n    #print(time_stamp)\n    #print(unique_time)\n    .get_stats(time_stamp,unique_time,in_node,out_node,node_id_old,node_id,bin_vector, max_node_id, undirected, \n              only_PA_num,              \n              compressed_unique_time,\n              Sum_m_k,n_tk,m_tk,m_t,offset_tk,z_j,node_degree,offset_m_tk,only_true_deg_matrix_num)\n\n    if (FALSE == only_PA) {\n      if (only_true_deg_matrix == FALSE)   \n          names(z_j)            <- node_id\n      colnames(node_degree) <- node_id\n    }\n   \n    names(node_id)    <- node_id\n    #now perform the final selection\n    true                           <- which(z_j >= deg_threshold)\n    \n    if (FALSE == only_PA) {\n        if (only_true_deg_matrix == FALSE) {  \n            if (length(true) == 0)\n                stop(\"Degree threshold is too high. Please decrease degree threshold.\")  \n            increase[inc >= deg_threshold] <- z_j\n            z_j                            <- z_j[true]\n            f_position                     <- f_position[true]\n        }\n    }\n    if (only_true_deg_matrix == FALSE) \n        node_degree                    <- node_degree[,true,drop = FALSE]\n    \n\n    result  <- list(offset_tk = offset_tk, offset_m_tk = offset_m_tk, net_type = net_type[1], \n                    n_tk = n_tk,m_tk = m_tk, bin_vector = bin_vector, \n                    Sum_m_k = Sum_m_k,\n                    node_degree = node_degree,m_t = m_t,z_j = z_j, initial_nodes = initial_nodes,\n                deg_thresh = deg_threshold, final_deg = final_deg, only_PA = only_PA, \n                increase = increase, start_deg = start_deg, \n                Binning = Binning, G = G, \n                CompressMode = CompressMode[1], f_position = f_position, compressed_unique_time = compressed_unique_time, begin_deg = begin_deg, end_deg = end_deg,\n                interval_length = interval_length,node_id = node_id_old, N = N, T = T, T_compressed = T_compressed,\n                deg.max = deg.max, CompressRatio = CompressRatio , CustomTime = CustomTime, only_true_deg_matrix = only_true_deg_matrix)\n    class(result) <- \"PAFitData\"\n   \n    return(result)\n}\n\n.onUnload <- function (libpath) {\n  library.dynam.unload(\"PAFit\", libpath)\n}\n",
    "created" : 1479362362506.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2606768300",
    "id" : "7204516E",
    "lastKnownWriteTime" : 1482373796,
    "last_content_update" : 1482373796593,
    "path" : "~/Dropbox/1- Program/PAFit/PAFit/R/GetStatistics.R",
    "project_path" : "R/GetStatistics.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}