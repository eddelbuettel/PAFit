{
    "collab_server" : "",
    "contents" : "# function to generate simulated network  2015-3-11 Thong Pham\nGenerateNet<-\nfunction(N = 1000, m = 1, mode = c(1,2,3), alpha = 1, beta = 1, sat_at = 100,\n         offset = 1, rate = 0, \n         shape = 0, mode_f = c(\"gamma\"), num_seed = 2, prob_m = FALSE,\n         meanlog = 0, sdlog = 1,\n         scale_pareto = 0.6,\n         shape_pareto = 2.5,\n         increase = FALSE, \n         multiple_node = 1, \n         specific_start = NULL,\n         log = FALSE, custom_PA = NULL){\n   # N: number of nodes\n   # Number of time-step: (N  - num_seed) / multiple_node\n   if (num_seed >= N)\n       stop(\"num_seed too large\")\n   if (num_seed < 2)\n      stop(\"num_seed too small\")\n   if (multiple_node > N - num_seed)\n      stop(\"Multiple node and/or num_seed are too large\")   \n   if ((alpha < 0 && mode != 1) || (beta < 0) || (sat_at < 0) || (rate < 0) || (shape < 0) || (m <= 0))\n       stop(\"The parameters must be non-negative\")  \n   if ((mode[1] != 1) && (mode[1] != 3) && (mode[1] != 2))\n       stop(\"Mode must be 1, 2 or 3 \")  \n    graph <- vector(\"list\", N)\n    # Node weights in the BA model. \n    switch(mode_f[1], \n    gamma = {\n    # gamma distribution\n      if (shape*rate > 0) \n          fitness <- rgamma(N,rate = rate,shape = shape)\n      else fitness <- rep(1,N)},\n     log_normal ={\n     # log_normal distribution\n        fitness <- rlnorm(N, meanlog = meanlog, sdlog = sdlog)\n     },\n    power_law = {\n        fitness <- rpareto(N, scale = scale_pareto, shape = shape_pareto)\n    },{\n    stop('mode_f must be either \"gamma\", \"log_normal\" or \"power_law\"')\n    }\n    )\n    names(fitness) <- 1:N\n    for (n in 2:num_seed)\n         graph[[n]] <- n - 1\n    \n    degree        <- rep(0,num_seed)\n    names(degree) <- 1:num_seed \n    for (i in 1:num_seed) {\n        count_degree <-table(graph[[i]][graph[[i]] <= i])\n        degree[labels(count_degree)[[1]]] <- degree[labels(count_degree)[[1]]] + \n                                             count_degree\n    }\n    P         <- degree\n    P[P == 0] <- offset\n    seed.graph.size <- length(P)\n    count <- 0\n    # n is the size of the current network\n    n <- seed.graph.size\n    while (n < N) {\t\n        # at each time_step: save n\n        n_old <- n\n        if (!is.null(custom_PA)) {\n            A                 <- custom_PA\n            final_A           <- A[length(A)]  \n            temp              <- A[P + 1]\n           #print(temp)\n            temp[is.na(temp)] <- final_A\n            P.sum             <- sum(temp*fitness[1:n_old])\n            node.weights      <- temp*fitness[1:n_old]/P.sum  \n        }\n        else\n        if (mode[1] == 1) {\n            P.sum        <- sum(P^alpha*fitness[1:n_old])\n            node.weights <- P^alpha*fitness[1:n_old]/P.sum\n        } else if (mode[1] == 2) {\n            temp         <- pmin(P,sat_at)^alpha\n            P.sum        <- sum(temp*fitness[1:n_old])\n            node.weights <- temp*fitness[1:n_old]/P.sum\n        } else {\n            temp         <- alpha*(log(P))^beta + 1 \n            P.sum        <- sum(temp*fitness[1:n_old])\n            node.weights <- temp*fitness[1:n_old]/P.sum\n        }\n        for (i in 1:multiple_node){\n        #Allow duplication:  \n            if (TRUE == increase) {\n                count <- count + 1  \n                nodes <- sort(sample(1:n_old,size = ifelse(log,max(round(log(count)),1),count),prob = node.weights, replace = TRUE))      \n            } else {\n            if (prob_m == TRUE) {\n                num_edge_temp <- rpois(1,lambda = m)\n            if (num_edge_temp > 0)\n                nodes <- sort(sample(1:n_old,num_edge_temp,prob = node.weights, replace = TRUE))\n            else nodes <- NULL\n            }\n           else\n               nodes <- sort(sample(1:n_old,size = m,prob = node.weights, replace = TRUE)) \n            }\n            ##########################################\n            degree  <- c(degree,0)\n            if (0 != length(nodes)) {\n                temp    <- table(nodes)\n                graph[[n+1]]  <- c(graph[[n+1]], nodes)\n                for(i in 1:length(temp)) { \n                    num_edge            <- as.numeric(temp[i]) \n                    node_name           <- as.numeric(labels(temp[i]))\n                    degree[node_name]   <- degree[node_name] + num_edge # Update degrees.\n                }\n            }\n            n <- n + 1\n            if (n == N) break  \n        }\n        P <- degree\n        P[degree == 0] <- offset     \n    }\n    \n    \n    num_of_edge          <- sum(unlist(lapply(graph,function(x) length(as.vector(x)))))\n    edge_list            <- matrix(nrow = num_of_edge,ncol = 3,0)\n    sum_m                <- 0\n    current_time_step    <- 0\n    i                    <- 1\n    flag_specific_start  <- !is.null(specific_start)\n    break_flag           <- FALSE\n    while (i <= N) {\n        if (break_flag == TRUE)\n            break  \n        #print(i)\n        if (i <= num_seed) {  \n            m_t <- length(graph[[i]][graph[[i]] <= i])\n            if (m_t > 0) { \n                temp  <- as.vector(graph[[i]])\n                edge_list[(sum_m + 1):(sum_m + m_t),3]   <-  0\n                edge_list[(sum_m + 1):(sum_m + m_t),1]   <-  i\n                edge_list[(sum_m + 1):(sum_m  +  m_t),2] <- temp \n                sum_m                                    <- sum_m + m_t\n            }\n           i <- i + 1 \n           if (i > N) { break_flag = TRUE;break}  \n        }\n        else {\n            current_time_step <- current_time_step + 1;  \n            if (1 == flag_specific_start) {\n                for (j in 1:specific_start) {\n                    if (i > N) {break_flag = TRUE;break}  \n                    m_t <- length(graph[[i]][graph[[i]] <= i])\n                    if (m_t > 0) { \n                      temp  <- as.vector(graph[[i]])\n                      edge_list[(sum_m + 1):(sum_m + m_t),3]   <-  current_time_step - 1\n                      edge_list[(sum_m + 1):(sum_m + m_t),1]   <-  i\n                      edge_list[(sum_m + 1):(sum_m  +  m_t),2] <- temp \n                      sum_m                                    <- sum_m + m_t\n                    }\n                    i <- i + 1  \n                    if (i > N) { break_flag = TRUE;break}  \n                }\n              flag_specfific_start <- 0;\n            } else \n            for (j in 1:multiple_node) {\n              if (i > N) {break_flag = TRUE; break}    \n              m_t <- length(graph[[i]][graph[[i]] <= i])\n                  if (m_t > 0) { \n                      temp  <- as.vector(graph[[i]])\n                      edge_list[(sum_m + 1):(sum_m + m_t),3]   <-  current_time_step\n                      edge_list[(sum_m + 1):(sum_m + m_t),1]   <-  i\n                      edge_list[(sum_m + 1):(sum_m  +  m_t),2] <-  temp \n                      sum_m                                    <- sum_m + m_t\n                  }\n            i <- i + 1\n            if (i > N) { break_flag = TRUE;break}  \n           }  \n      }\n  }\n  return(list(graph = edge_list, fitness = fitness))\n}\n",
    "created" : 1476080839917.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3227574692",
    "id" : "A70A327D",
    "lastKnownWriteTime" : 1475720964,
    "last_content_update" : 1475720964,
    "path" : "~/Dropbox/1- Program/PAFit/PAFit/R/GenerateNet.R",
    "project_path" : "R/GenerateNet.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}