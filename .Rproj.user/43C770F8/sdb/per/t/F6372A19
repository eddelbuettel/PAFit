{
    "collab_server" : "",
    "contents" : "\nCreateDataCV<- function(data, p = 0.75, G = 50, \n                        net_type = \"directed\",deg_thresh = 0, exclude_end = FALSE) {\n  data              <- data[order(data[,3], decreasing = FALSE),]\n  time_stamp        <- as.vector(data[,3])\n  in_node           <- as.vector(data[,2])\n  out_node          <- as.vector(data[,1])\n  node_id           <- sort(union(in_node,out_node))\n  names(node_id)    <- node_id\n  unique_time       <- sort(unique(time_stamp))\n  T                 <- length(unique_time)\n  N                 <- length(node_id) \n  appear            <- rep(0,N)\n  names(appear)     <- node_id\n  first_time        <- time_stamp[1]\n  edge_cumsum       <- cumsum(as.vector(table(time_stamp[time_stamp != first_time]))) \n  edge_ratio        <- edge_cumsum/edge_cumsum[length(edge_cumsum)]\n  use_time          <- unique_time[which(edge_ratio >= p)[1]]\n  \n  data_new          <- data[time_stamp <= use_time, ]\n  stats             <- GetStatistics(data_new, net_type = net_type, \n                                     Binning = TRUE, G = G, deg_threshold = deg_thresh)\n  appear[as.character(stats$f_position)] <- 1\n  deg                                    <- stats$final_deg[as.character(stats$f_position)]\n  if (FALSE == exclude_end) {\n  if (net_type == \"directed\") {\n      prob_em_each              <- matrix(0,nrow = sum(unique_time > use_time),ncol = length(stats$f_position))\n      colnames(prob_em_each)    <- stats$f_position\n      m_each                    <- rep(0,sum(unique_time > use_time))\n      deg_each                  <- matrix(0,nrow = sum(unique_time > use_time),ncol = length(stats$f_position))\n      colnames(deg_each)        <- stats$f_position\n      deg_each[1,]              <- deg\n      time_each                 <- unique_time[unique_time > use_time]\n      for (i in 1:length(time_each)){\n          new_links      <- in_node[time_stamp == time_each[i]]\n          new_links      <- new_links[appear[as.character(new_links)] == 1]\n          m_each[i]      <- length(new_links)\n          aaa            <- table(new_links)\n          prob_em_each[i,labels(aaa)[[1]]] <- aaa\n          prob_em_each[i,labels(aaa)[[1]]] <- prob_em_each[i,labels(aaa)[[1]]]/ m_each[i] \n          if (i < length(time_each)) {\n              deg_each[i+1,]                 <- deg_each[i,];    \n              deg_each[i+1,labels(aaa)[[1]]] <- deg_each[i+1,labels(aaa)[[1]]] + aaa\n          }\n      }\n  } else { #undirected network\n        prob_em_each              <- matrix(0,nrow = sum(unique_time > use_time),ncol = length(stats$f_position))\n        colnames(prob_em_each)    <- stats$f_position\n        m_each                    <- rep(0,sum(unique_time > use_time))\n        deg_each                  <- matrix(0,nrow = sum(unique_time > use_time),ncol = length(stats$f_position))\n        colnames(deg_each)        <- stats$f_position\n        deg_each[1,]              <- deg\n        time_each                 <- unique_time[unique_time > use_time]\n        for (i in 1:length(time_each)){\n            new_in_links      <- in_node[time_stamp == time_each[i]]\n            new_in_links      <- new_in_links[appear[as.character(new_in_links)] == 1]\n            new_out_links     <- out_node[time_stamp == time_each[i]]\n            new_out_links     <- new_out_links[appear[as.character(new_out_links)] == 1]\n            m_each[i]         <- length(c(new_in_links,new_out_links))\n            aaa               <- table(c(new_in_links,new_out_links))\n            prob_em_each[i,labels(aaa)[[1]]] <- aaa\n            prob_em_each[i,labels(aaa)[[1]]] <- prob_em_each[i,labels(aaa)[[1]]]/ m_each[i] \n            if (i < length(time_each)) {\n                deg_each[i+1,]                 <- deg_each[i,];    \n                deg_each[i+1,labels(aaa)[[1]]] <- deg_each[i+1,labels(aaa)[[1]]] + aaa\n        }\n      }\n    \n  }\n  result            <- list(stats        = stats       , deg_each = deg_each,\n                            m_each       = m_each      ,\n                            prob_em_each = prob_em_each, use_time = use_time)\n  class(result)     <- \"CV_Data\"\n  return(result)\n  } else {\n  #exclude_end = TRUE\n    deg_max <- stats$deg.max\n    if (net_type == \"directed\") {\n      prob_em_each              <- matrix(-1,nrow = sum(unique_time > use_time),ncol = length(stats$f_position))\n      colnames(prob_em_each)    <- stats$f_position\n      m_each                    <- rep(-1,sum(unique_time > use_time))\n      deg_each                  <- matrix(-1,nrow = sum(unique_time > use_time),ncol = length(stats$f_position))\n      colnames(deg_each)        <- stats$f_position\n      \n      deg_vec                   <- deg\n      time_each                 <- unique_time[unique_time > use_time]\n      for (i in 1:length(time_each)){\n        new_links      <- in_node[time_stamp == time_each[i]]\n        new_links      <- new_links[appear[as.character(new_links)] == 1]\n        ### IMPORTANT: remove nodes that go outside the range of the degree distribution of testing data\n        new_links_final <- new_links[deg_vec[as.character(new_links)] < deg_max]\n        m_each[i]       <- length(new_links_final)\n        aaa             <- table(new_links)\n        bbb             <- table(new_links_final)\n        prob_em_each[i,labels(bbb)[[1]]] <- bbb\n        prob_em_each[i,labels(bbb)[[1]]] <- prob_em_each[i,labels(bbb)[[1]]]/ m_each[i] \n        \n        deg_each[i,labels(bbb)[[1]]]       <- deg_vec[labels(bbb)[[1]]]\n        \n        #update new degree vector for the next step \n        deg_vec[labels(aaa)[[1]]]          <- deg_vec[labels(aaa)[[1]]] + aaa;  \n      }\n      result            <- list(stats        = stats       , deg_each = deg_each,\n                                m_each       = m_each      ,\n                                prob_em_each = prob_em_each, use_time = use_time)\n      class(result)     <- \"CV_Data\"\n      return(result)\n      \n    }\n    \n  }\n}\n\n\n",
    "created" : 1477965450223.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "24|29|74|2|\n",
    "hash" : "4216340706",
    "id" : "F6372A19",
    "lastKnownWriteTime" : 1484905255,
    "last_content_update" : 1484905626982,
    "path" : "~/Dropbox/1- Program/PAFit/PAFit/R/CreateDataCV.R",
    "project_path" : "R/CreateDataCV.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}