{
    "contents" : "# function to estimate jointly the attachment function and node fitness  2015-3-11 Thong Pham\nPAFit <- function(data, only_PA = FALSE, only_f = FALSE, mode_f = c(\"Linear_PA\", \"Constant_PA\",\"Log_linear\"),\n                  true_A = NULL, true_f = NULL,\n                  s = 1,\n                  auto_lambda = TRUE, r = 0.01, \n                  lambda = 1, weight_PA_mode = 1, auto_stop = TRUE,stop_cond = 10^-9, iteration = 20, \n                  max_iter = 200000,\n                  debug = FALSE, step_size = 0.5,\n                  alpha_start = 1,\n                  normalized_f = FALSE, interpolate = TRUE, q = 1,\n                  debug_PA = FALSE, mode_reg_A = 2, start_mode_A = \"Log_linear\", start_mode_f = \"Random\", prob_PA = 0.9,\n                  ...) {\n    if ((data$only_PA == TRUE) & (only_PA == FALSE)) {\n        stop(\"Error: the data do not support estimation of node fitness. \n              Please re-run GetStatistics again with the option 'only_PA = FALSE', \n              or run PAFit with option 'only_PA = TRUE'\")\n    }\n    estimate_shape <- FALSE\n    shape <- s\n    rate  <- s\n    ratio <- r\n    if (s <= 0)\n        stop(\"Error: shape and rate should be positive number\")\n  \n    non_zero_theta     <- which(data$Sum_m_k > 0)\n    num_nonzero        <- length(non_zero_theta)\n    theta              <- rep(1,length(data$Sum_m_k))\n    \n    \n    \n     for (ii in 1:length(theta))\n        if ((mode_f[1] == \"Constant_PA\") & (only_f == TRUE)) \n        {\n            theta[ii] <- 1;  \n        } else if ((only_f == TRUE) & (!is.null(true_A))) {\n            theta[ii] <- true_A[ii];    \n        }\n        else if (\"Log_linear\" == start_mode_A[1]){    \n            if (ii <= data$start_deg & ii %in% non_zero_theta)\n               theta[ii] <- ii^alpha_start\n            else \n            if (ii > data$start_deg & ii %in% non_zero_theta)\n               theta[ii] <- data$begin_deg[ii - data$start_deg]^alpha_start\n        } else if (\"Random\" == start_mode_A[1]) {\n            theta <- runif(length(theta),0,1);  \n        }\n    \n    alpha <- 1.0\n    if (theta[length(theta)] == 1 || theta[length(theta)] == 0)\n        theta[length(theta)] <- theta[length(theta) - 1] + 1\n    #print(theta)\n    theta[which(theta <= 0)] <- 1\n    if (mode_f[1] != \"Log_linear\")\n        theta[-non_zero_theta] <- 0\n    if (mode_f[1] == \"Log_linear\") {\n      alpha <- 1.0 * alpha_start; #starting value of alpha\n    }\n    else theta         <- theta/sum(theta)\n    #print(theta)\n    #if (include_zero == 0)\n    non_zero_f    <- which(data$z_j >= 0)\n\n    #if (shape <= 1 & rate <= 1)\n    #    non_zero_f <- which(data$z_j > 0)\n    if (\"Constant\" == start_mode_f)\n        f             <- rep(2,length(data$f_position))\n    else if (\"Random\" == start_mode_f)\n        f             <- rgamma(n = length(data$f_position), shape = s, rate = s);\n    f             <- length(f) * f/sum(f)\n    #if (shape < 1 & rate < 1)\n    #     f[data$z_j == 0] <- 0\n    \n    if (TRUE == only_PA) {\n        if (is.null(true_f))\n            f[] <- 1\n        else\n            f[] <- true_f  \n    }\n    log_likelihood   <- vector()\n    # get the center of each bin\n    center_k    <- rep(0, length(theta)) \n    center2_k   <- center_k\n    if (data$start_deg > 0) {\n      center_k[1:data$start_deg]  <- 0:(data$start_deg - 1)\n      center2_k[1:data$start_deg] <- 0:(data$start_deg - 1)\n    }\n    for (i in 1:data$G) {\n      if (data$begin_deg[i] != 0) {\n        # center_k[i]  <- round((data$begin_deg[i] + data$end_deg[i])/2)  \n        #center_k[data$start_deg + i] <- round(data$begin_deg[i]*sqrt((data$begin_deg[i] + data$interval_length[i] - 1)/ data$begin_deg[i]))\n        #center_k[data$start_deg + i] <- data$begin_deg[i]\n        center_k[data$start_deg + i] <- data$end_deg[i]\n        #center2_k[data$start_deg + i] <- round((data$begin_deg[i] + data$end_deg[i])/2)  \n        center2_k[data$start_deg + i] <- data$end_deg[i]\n      } else {\n        center_k[data$start_deg + i] <- data$end_deg[i]  \n        #center2_k[i]  <- round((data$begin_deg[i] + data$end_deg[i])/2)   \n        center2_k[data$start_deg + i] <- data$end_deg[i]\n      }\n      #        \n    }\n    #print(center_k)\n      \n\n    if (0 == mode_reg_A) {\n        update_theta   <- non_zero_theta[-c(1,2,num_nonzero,num_nonzero - 1)]\n        noupdate_theta <- non_zero_theta[c(1,2,num_nonzero,num_nonzero - 1)]\n        minus_1 <- non_zero_theta[-c(1,num_nonzero,num_nonzero - 1,num_nonzero-2)]\n        minus_2 <- non_zero_theta[-c(num_nonzero,num_nonzero - 1,num_nonzero-2,num_nonzero-3)] \n        plus_1  <- non_zero_theta[-c(1,2,3,num_nonzero)]\n        plus_2  <- non_zero_theta[-c(1,2,3,4)] \n    } else if (1 == mode_reg_A) {\n          ok_log     <- which(center_k[non_zero_theta] > 1)\n          not_ok_log <- which(center_k[non_zero_theta] <= 1)\n          num_ok_log <- length(ok_log) \n          #print(not_ok_log)\n          update_theta   <- non_zero_theta[ok_log[-c(1, 2, num_ok_log, num_ok_log - 1)]]\n          noupdate_theta <- non_zero_theta[ok_log[c(1, 2, num_ok_log, num_ok_log - 1)]]\n          minus_1 <- non_zero_theta[ok_log[-c(1, num_ok_log, num_ok_log - 1, num_ok_log - 2)]]\n          minus_2 <- non_zero_theta[ok_log[-c(num_ok_log, num_ok_log - 1, num_ok_log - 2, num_ok_log - 3)]] \n          plus_1  <- non_zero_theta[ok_log[-c(1, 2, 3, num_ok_log)]]\n          plus_2  <- non_zero_theta[ok_log[-c(1, 2, 3, 4)]] \n    } else if (2 == mode_reg_A) {\n          ok_log     <- which(center_k[non_zero_theta] > 0)\n          not_ok_log <- which(center_k[non_zero_theta] == 0)\n          num_ok_log <- length(ok_log) \n          #print(not_ok_log)\n          update_theta   <- non_zero_theta[ok_log[-c(1, 2, num_ok_log, num_ok_log - 1)]]\n          noupdate_theta <- non_zero_theta[ok_log[c(1, 2, num_ok_log, num_ok_log - 1)]]\n          minus_1 <- non_zero_theta[ok_log[-c(1, num_ok_log, num_ok_log - 1, num_ok_log - 2)]]\n          minus_2 <- non_zero_theta[ok_log[-c(num_ok_log, num_ok_log - 1, num_ok_log - 2, num_ok_log - 3)]] \n          plus_1  <- non_zero_theta[ok_log[-c(1, 2, 3, num_ok_log)]]\n          plus_2  <- non_zero_theta[ok_log[-c(1, 2, 3, 4)]] \n          u       <- matrix(0,nrow = num_ok_log, ncol = num_ok_log)\n          for (k1 in 2:(num_ok_log - 1)) {\n              u[k1,k1]       <- 1/(log(center_k[non_zero_theta[ok_log[k1 + 1 ]]]) - log(center_k[non_zero_theta[ok_log[k1]]])) +\n                                          1/(log(center_k[non_zero_theta[ok_log[k1]]]) - log(center_k[non_zero_theta[ok_log[k1 - 1]]])) \n              u[k1,k1 - 1]   <- 1/(log(center_k[non_zero_theta[ok_log[k1]]]) - log(center_k[non_zero_theta[ok_log[k1 - 1]]]))\n              u[k1,k1 + 1]   <- 1/(log(center_k[non_zero_theta[ok_log[k1 + 1 ]]]) - log(center_k[non_zero_theta[ok_log[k1]]]))\n          }\n          extract_u <- function(i,j) {\n            result <- NULL\n            for (index in 1:length(i))\n              result <- c(result,u[i[index],j[index]])  \n            return(result)\n          }\n          update_k <- 3:(num_ok_log-2)\n          #print(center_k[non_zero_theta[ok_log]])\n          #print(u)     \n    }\n    \n    PA_offset <- 1\n    theta[1]  <- PA_offset\n    \n    cal_reg_A <- function() {\n      if (0 == mode_reg_A) {\n      return(sum(lambda * w_k[non_zero_theta[-c(1,num_nonzero)]]*(log(theta[non_zero_theta[-c(1,2)]]) + \n                 log(theta[non_zero_theta[-c(num_nonzero,num_nonzero - 1)]]) - \n                 2 * log(theta[non_zero_theta[-c(1,num_nonzero)]]))^2))\n      }\n      else if (1 == mode_reg_A) {\n        return(sum(lambda * w_k[non_zero_theta[ok_log[-c(1,num_ok_log)]]]*\n                     (log(theta[non_zero_theta[ok_log[-c(1,2)]]]) / log(center_k[non_zero_theta[ok_log[-c(1,2)]]]) + \n                      log(theta[non_zero_theta[ok_log[-c(num_ok_log,num_ok_log - 1)]]]) / \n                        log(center_k[non_zero_theta[ok_log[-c(num_ok_log,num_ok_log - 1)]]])  - \n                      2 * log(theta[non_zero_theta[ok_log[-c(1,num_ok_log)]]]) / \n                        log(center_k[non_zero_theta[ok_log[-c(1,num_ok_log)]]]) )^2))\n      } else if (2 == mode_reg_A) {\n        return(sum(lambda * w_k[non_zero_theta[ok_log[-c(1,num_ok_log)]]] *\n                      ( (\n                          (log(theta[non_zero_theta[ok_log[-c(1,2)]]]) -  log(theta[non_zero_theta[ok_log[-c(1,num_ok_log)]]])) / \n                         (log(center_k[non_zero_theta[ok_log[-c(1,2)]]]) -  log(center_k[non_zero_theta[ok_log[-c(1,num_ok_log)]]]))\n                         ) -  \n                          (\n                          (log(theta[non_zero_theta[ok_log[-c(1,num_ok_log)]]]) -  log(theta[non_zero_theta[ok_log[-c(num_ok_log,num_ok_log - 1)]]])) / \n                          (log(center_k[non_zero_theta[ok_log[-c(1,num_ok_log)]]]) -  log(center_k[non_zero_theta[ok_log[-c(num_ok_log, num_ok_log - 1)]]])) \n                          ) \n                        )^2) + \n                     lambda * w_k[non_zero_theta[not_ok_log]] * \n                     (log(theta[non_zero_theta[not_ok_log]]) - log(theta[non_zero_theta[ok_log[1]]])) ^2 );  \n        \n      }\n    }\n    #starting value for the offset\n    offset <- 1\n    #weights of the regularization term\n    if (weight_PA_mode[1] == 0)\n        w_k <- data$Sum_m_k/sum(data$Sum_m_k)\n    else {\n        if (weight_PA_mode[1] == 1)\n            w_k <- rep(1/length(theta),length(theta))\n        else if (weight_PA_mode[1] == 2)\n            w_k <- 1/data$Sum_m_k/sum(1/data$Sum_m_k)\n    }\n    \n    if (TRUE == auto_lambda) {\n       #lambda <- ratio   \n        lambda <- ratio * sum(data$Sum_m_k)\n    }\n    if (TRUE == auto_stop)\n        iteration <- max_iter\n\n    normalized_const <- rep(0, dim(data$n_tk)[1])\n    alpha_series <- c()\n    \n    break_flag  <- FALSE\n    count_break <- 0\n    \n    objective_function_value <- function(theta,f,offset,normalized_const) {\n        time_non_zero       <- which(normalized_const > 0)\n        non_zero_f_temp     <- which(f > 0)\n        non_zero_theta_temp <- which(theta > 0) \n        if ((FALSE == only_PA) || ((TRUE == only_PA) && (!is.null(true_f)))) {\n          value <- sum(data$z_j[non_zero_f_temp] * log(f[non_zero_f_temp])) + \n                                 sum(data$offset_m_tk)*log(offset) +  \n                                 (shape - 1) * log(offset) - rate * offset +    \n                                 sum(data$Sum_m_k[non_zero_theta_temp] * log(theta[non_zero_theta_temp])) - \n                                 sum(data$m_t[time_non_zero] * log(normalized_const[time_non_zero])) + \n                                 (shape - 1) * (sum(log(f[non_zero_f_temp]))) - rate * sum(f[non_zero_f_temp]) - cal_reg_A()\n        #print(log_likelihood)\n      }\n      else if (is.null(true_f) && (TRUE == only_PA))  { \n          value <- sum(data$Sum_m_k[non_zero_theta_temp] * log(theta[non_zero_theta_temp])) - \n                               sum(data$m_t[time_non_zero] * log(normalized_const[time_non_zero])) - cal_reg_A()\n      }\n      else  if ((is.null(true_A) && (TRUE == only_f)))\n          value <- sum(data$z_j[non_zero_f_temp] * log(f[non_zero_f_temp])) - \n                                 sum(data$m_t[time_non_zero] * log(normalized_const[time_non_zero])) + \n                                 sum(data$offset_m_tk)*log(offset) + \n                                 (shape - 1) * log(offset) - rate * offset +    \n                                 (shape - 1) * (sum(log(f[non_zero_f_temp]))) - rate * sum(f[non_zero_f_temp])  \n      return(value)\n    }\n    \n    if (q > 1) {\n      parameter_save <- matrix(0,nrow = length(theta) + length(f) + 1, ncol = q)\n      U              <- matrix(0,nrow = length(theta) + length(f) + 1, ncol = q - 1)\n      V              <- matrix(0,nrow = length(theta) + length(f) + 1, ncol = q - 1)\n      candidate      <- rep(0,length(theta) + length(f) + 1)              # theta, f, and offset values\n    }\n    \n    candidate_ok     <- 0\n    candidate_accept <- 0\n    \n    \n    for (i in 1:iteration) {\n        if (mode_f[1] != \"Log_linear\") {\n        if ((FALSE == only_PA) || ((TRUE == only_PA) && (!is.null(true_f)))) {\n            .normalized_constant(normalized_const,data$node_degree,theta,f,data$offset_tk,offset) \n        } else if (is.null(true_f) && (TRUE == only_PA)) {\n            normalized_const <- as.vector(data$n_tk[,non_zero_theta]%*%theta[non_zero_theta])\n        }\n          \n        #print(cal_reg_A());  \n        #print(normalized_const);\n        #print(theta);\n        #print(log(theta[non_zero_theta]));\n        #print(offset)\n        \n        log_likelihood    <- c(log_likelihood,objective_function_value(theta,f,offset,normalized_const))  ;\n        \n        time_non_zero     <- which(normalized_const != 0)\n        non_zero_f_temp   <- which(f > 0)\n        \n\n        if (TRUE == debug) {\n            print(log_likelihood[length(log_likelihood)])\n        }\n        if (length(log_likelihood) > 1)\n          if (log_likelihood[length(log_likelihood)] < log_likelihood[length(log_likelihood) - 1])\n              stop(\"Warning: Log likelihood decreased.\")  \n        \n        \n        if (TRUE == auto_stop)\n            if (length(log_likelihood) > 1)\n             tryCatch({if (abs(log_likelihood[length(log_likelihood)] - log_likelihood[length(log_likelihood) - 1]) / \n                 (abs(log_likelihood[length(log_likelihood) - 1]) + 1) < stop_cond)\n                  break_flag <- TRUE;},error = function(e) { #print(as.vector(normalized_const));print(f[non_zero_f]);\n                                                             #print(non_zero_f);\n                                                             break_flag <- TRUE;})\n       \n        \n        ######################### quasi-Newton acceleration #########################\n        ####  calculate the smallest approximation to the second derivative at current point ####\n        if ((FALSE == only_f) && (FALSE == only_PA)) {\n            if (q > 1) {\n                flag <- 0  \n                if (i > q) {\n                current_pos <- c(theta,f,offset)\n                U <- parameter_save[,1:(q-1)] - parameter_save[,q]\n                V <- parameter_save[,2:q]     - current_pos            \n            \n                if ((FALSE == only_f) && (FALSE == only_PA)) {\n                    candidate <- tryCatch(current_pos + step_size * ifelse(q > 2, V%*%solve(crossprod(U,U) - \n                                                          crossprod(U,V),crossprod(U, V[,q-1])), 1/(sum(U* U) - sum(U*V)) * sum(V*U) * V), \n                                          error = function(e) {#print(\"Problem with inversion\"); \n                                          flag <- 1; return(current_pos)})\n                    positive <- prod(candidate > 0)      \n                }\n           \n                if ((0 == flag) && (1 == positive)) {\n                    candidate_ok <- candidate_ok + 1\n              \n                theta_temp                 <- candidate[1:length(theta)]\n                f_temp                     <- candidate[(length(theta) + 1):(length(theta) + length(f))]\n                offset_temp                <- candidate[length(candidate)]  \n                normalized_const_temp      <- rep(0, dim(data$n_tk)[1])\n                \n                if (FALSE == only_PA) {\n                    .normalized_constant(normalized_const_temp,data$node_degree,theta_temp,f_temp,data$offset_tk,offset_temp)\n                }  \n                else if (TRUE == only_PA)\n                    normalized_const_temp <- as.vector(data$n_tk[,non_zero_theta]%*% theta_temp[non_zero_theta])\n              \n                time_temp <- which(normalized_const_temp != 0)   \n                log_candidate <- objective_function_value(theta_temp,f_temp,offset_temp,normalized_const_temp)\n                if (log_candidate > log_likelihood[length(log_likelihood)]) {\n                    theta  <- candidate[1:length(theta)]\n                    f      <- candidate[(length(theta) + 1):(length(theta) + length(f))]\n                    offset <- candidate[length(candidate)]  \n                    log_likelihood[length(log_likelihood)]  <- log_candidate\n                    normalized_const                        <- normalized_const_temp\n                }\n                else {\n                #print(paste(\"ll of rejected candidate:\",log_candidate))\n                }\n                }\n                parameter_save[,1:(q-1)]             <- parameter_save[,2:q] \n                parameter_save[1:length(theta),q]    <- theta\n                parameter_save[(length(theta) + 1):(length(theta) + length(f)),q] <- f\n                parameter_save[dim(parameter_save)[1],q] <- offset\n              }\n              else {\n                parameter_save[1:length(theta),i]    <- theta\n                parameter_save[(length(theta) + 1):(length(theta) + length(f)),i] <- f\n                parameter_save[dim(parameter_save)[1],i] <- offset\n          }\n        }\n        }\n        ############### End of quasi-Newton acceleration ################\n        \n        \n        if (break_flag) {\n          if (count_break == 1)  \n            break;   \n        } else { \n          break_flag  <- FALSE\n          count_break <- 1\n        }\n        if (count_break == 1) {\n          PA_or_f <- 3\n        } else {\n          if (0 <= prob_PA & 1 >= prob_PA) {\n            PA_or_f <- sample(c(0,1), size = 1,prob = c(prob_PA,1 - prob_PA))\n          } else PA_or_f <- 3\n        }\n        #print(offset)\n        .normalized_constant(normalized_const, data$node_degree,theta,f,data$offset_tk,offset)\n        \n        \n         if (1 == PA_or_f || 3 == PA_or_f) {\n       \n        ##################### Update f ######################\n        if (FALSE == only_PA){\n            \n            .update_f(f,non_zero_f,data$node_degree,theta,data$z_j,normalized_const,data$m_t,shape,rate,offset)\n            \n          #print(f)\n          \n          ### NORMALIZED f\n          #normalize_f <- mean(c(f,offset))\n          #f           <- f/normalize_f\n          #offset      <- offset/normalize_f\n          \n          \n            #update shape and rate\n          if ((TRUE == only_f) && (estimate_shape == TRUE)) {\n              N <- sum(data$z_j > 0)\n              #print(shape)\n              opti <- function(x) {N * log(x) + N -  N * digamma(x) + sum(log(f[non_zero_f])) - sum(f[non_zero_f])} \n              shape <- tryCatch(uniroot(opti,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                error = function(e) {return(shape)})\n              rate  <- shape\n             \n           }\n            #update offset\n            #if (data$deg_thresh > 0)\n            .normalized_constant(normalized_const, data$node_degree,theta,f,data$offset_tk,offset)\n            offset <- .update_offset(data$offset_tk, data$offset_m_tk, theta, normalized_const,data$m_t, shape,rate)\n            if (debug_PA == TRUE)\n                print(paste0(\"Offset: \",offset))\n            .normalized_constant(normalized_const, data$node_degree,theta,f,data$offset_tk,offset)\n            time_non_zero     <- which(normalized_const != 0)\n            #print(f)\n        }\n        }\n        if (0 == PA_or_f || 3 == PA_or_f) {\n        #### Update PA_offset if mode_f = \"Linear_PA\" #####\n        if ((TRUE == only_f) && (mode_f[1] == \"Linear_PA\")) {\n            PA_offset <- .update_PA_offset(normalized_const,f,data$node_degree,data$m_t,data$Sum_m_k,\n                                           data$offset_tk);\n            theta[1]  <- PA_offset\n        }\n        #####################  Update A #######################\n        \n        if (FALSE == only_f) {\n            if ((FALSE == only_PA) || ((TRUE == only_PA) && (!is.null(true_f)))) {\n                #print(\"problem in coeff theta\")\n                temp5  <- .coeff_theta(data$node_degree, f, normalized_const,data$m_t,data$start_deg + data$G)   \n                if (length(time_non_zero) > 1) {\n                    temp4  <- temp5[non_zero_theta] + colSums(data$m_t[time_non_zero] / normalized_const[time_non_zero] * offset *\n                                                          data$offset_tk[time_non_zero,non_zero_theta])\n                } else {\n                    temp4  <- temp5[non_zero_theta] + data$m_t[time_non_zero] / normalized_const[time_non_zero] * offset *\n                                                              data$offset_tk[time_non_zero,non_zero_theta]  \n                }\n                \n              \n            }\n            else {\n                if (length(time_non_zero) > 1) {  \n                    temp4 <- colSums(data$m_t[time_non_zero]/normalized_const[time_non_zero] * \n                                     data$n_tk[time_non_zero,non_zero_theta])\n                } else {\n                    temp4 <- data$m_t[time_non_zero]/normalized_const[time_non_zero] * \n                                     data$n_tk[time_non_zero,non_zero_theta]  \n                }\n            }\n           #print(temp4)\n           #print(ok_log)\n            if (lambda <= 0) {\n              \n                    theta[non_zero_theta] <- data$Sum_m_k[non_zero_theta]/temp4\n            }\n            else if (0 == mode_reg_A) {\n                g_1  <- function(x) {\n                        (data$Sum_m_k[non_zero_theta[1]] - 2*w_k[non_zero_theta[2]] * lambda * (-2 * log(theta[non_zero_theta[2]]) + \n                        log(theta[non_zero_theta[3]]) - 3 * log(theta[non_zero_theta[1]])))/x -   \n                         temp4[1] - 8 * lambda * w_k[non_zero_theta[2]] * log(x) / x}\n                \n                g_2 <- function(x) {\n                       (data$Sum_m_k[non_zero_theta[2]] - 2*lambda * \n                          (2*w_k[non_zero_theta[2]]*(-2*log(theta[non_zero_theta[2]]) -log(theta[non_zero_theta[3]]) - log(theta[non_zero_theta[1]])) + \n                             w_k[non_zero_theta[3]]*(-2*log(theta[non_zero_theta[3]]) +log(theta[non_zero_theta[4]]) -3*log(theta[non_zero_theta[2]]) ))) / x - \n                         temp4[2] - (16*w_k[non_zero_theta[2]] + 8*w_k[non_zero_theta[3]]) * lambda * log(x) / x}\n               g_semiend <- function(x) {\n                            (data$Sum_m_k[non_zero_theta[num_nonzero - 1]] - 2*lambda * \n                            (2*w_k[non_zero_theta[num_nonzero - 1]]*(-2*log(theta[non_zero_theta[num_nonzero - 1]]) - log(theta[non_zero_theta[num_nonzero]]) - log(theta[non_zero_theta[num_nonzero - 2]])) +\n                             w_k[non_zero_theta[num_nonzero -2]] *(-3*log(theta[non_zero_theta[num_nonzero - 1]]) + log(theta[non_zero_theta[num_nonzero - 3]]) - 2*log(theta[non_zero_theta[num_nonzero - 2]])))) / x - \n                              temp4[num_nonzero - 1] - \n                              (16*w_k[non_zero_theta[num_nonzero - 1]] + 8*w_k[non_zero_theta[num_nonzero -2]]) * lambda * log(x) / x}\n               g_end     <-  function(x) {\n                             (data$Sum_m_k[non_zero_theta[num_nonzero]] - 2*lambda * w_k[non_zero_theta[num_nonzero -1]] *(-3*log(theta[non_zero_theta[num_nonzero]]) + log(theta[non_zero_theta[num_nonzero - 2]]) - 2*log(theta[non_zero_theta[num_nonzero - 1]]))) / x  -   \n                             temp4[num_nonzero] - 8*w_k[non_zero_theta[num_nonzero -1]]*lambda*log(x)/x}  \n\n               U_1 <- data$Sum_m_k[update_theta] - 2 * lambda * (2*w_k[update_theta]*(-2*log(theta[update_theta]) - log(theta[plus_1]) - log(theta[minus_1])) + \n                                                                   w_k[minus_1]*(-3*log(theta[update_theta]) + log(theta[minus_2]) - 2*log(theta[minus_1])) + \n                                                                   w_k[plus_1]*(-2*log(theta[plus_1]) + log(theta[plus_2]) - 3*log(theta[update_theta])))\n               U_2 <- (16*w_k[update_theta] + 8*w_k[minus_1] + 8*w_k[plus_1]) * lambda\n               U_3 <- temp4[-c(1,2,num_nonzero-1,num_nonzero)]\n               theta[non_zero_theta[1]] <- tryCatch(uniroot(g_1,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                    error = function(e) {return(theta[non_zero_theta[1]])})\n        \n               theta[non_zero_theta[2]] <- tryCatch(uniroot(g_2,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                   error = function(e) {return(theta[non_zero_theta[2]])})\n               #parallelization here\n               for (jj in 1:length(update_theta)) {\n                  g <- function(x){U_1[jj]/x - U_2[jj]*log(x)/x - U_3[jj]}\n                  theta[update_theta[jj]] <- tryCatch(uniroot(g,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                      error = function(e) theta[update_theta[jj]])\n               }\n               theta[non_zero_theta[num_nonzero - 1]] <- tryCatch(uniroot(g_semiend,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                                  error = function(e) \n                                                                  {return(theta[non_zero_theta[num_nonzero - 1]])})\n               theta[non_zero_theta[num_nonzero]] <- tryCatch(uniroot(g_end,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                              error = function(e) {return(theta[non_zero_theta[num_nonzero]])})\n            }\n            else if (1 == mode_reg_A) {\n                #mode_reg_A == 1  \n              g_1  <- function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[1]]] - 2 * w_k[non_zero_theta[ok_log[2]]] * lambda * (-2 * log(theta[non_zero_theta[ok_log[2]]]) / \n                                                                                                          log(center_k[non_zero_theta[ok_log[2]]])  + \n                                                                                          log(theta[non_zero_theta[ok_log[3]]]) / log(center_k[non_zero_theta[ok_log[3]]]) - \n                                                                                          3 * log(theta[non_zero_theta[ok_log[1]]]) / log(center_k[non_zero_theta[ok_log[1]]])  ))/x -   \n                  temp4[ok_log[1]] - 8 * lambda * w_k[non_zero_theta[ok_log[2]]] * log(x) / x / log(center_k[non_zero_theta[ok_log[1]]])}\n              \n              g_2 <- function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[2]]] - 2 * lambda * \n                   (2 * w_k[non_zero_theta[ok_log[2]]] * (- 2 * log(theta[non_zero_theta[ok_log[2]]]) / log(center_k[non_zero_theta[ok_log[2]]]) - \n                                                            log(theta[non_zero_theta[ok_log[3]]]) / log(center_k[non_zero_theta[ok_log[3]]]) - \n                                                            log(theta[non_zero_theta[ok_log[1]]]) / log(center_k[non_zero_theta[ok_log[1]]])   ) + \n                      w_k[non_zero_theta[ok_log[3]]]*(- 2 * log(theta[non_zero_theta[ok_log[3]]]) / log(center_k[non_zero_theta[ok_log[3]]])  +\n                                                        log(theta[non_zero_theta[ok_log[4]]]) / log(center_k[non_zero_theta[ok_log[4]]]) -\n                                                        3 * log(theta[non_zero_theta[ok_log[2]]]) / log(center_k[non_zero_theta[ok_log[2]]])  ))) / x - \n                  temp4[ok_log[2]] - (16*w_k[non_zero_theta[ok_log[2]]] + 8*w_k[non_zero_theta[ok_log[3]]]) * lambda * log(x) / x / log(center_k[non_zero_theta[ok_log[2]]])}\n          \n                  g_semiend <- function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[num_ok_log - 1]]] - 2*lambda * \n                   (2*w_k[non_zero_theta[ok_log[num_ok_log - 1]]] * ( -2 * log(theta[non_zero_theta[ok_log[num_ok_log - 1]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log - 1]]]) - \n                                                                        log(theta[non_zero_theta[ok_log[num_ok_log]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log]]]) - \n                                                                  log(theta[non_zero_theta[ok_log[num_ok_log - 2]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log - 2]]]) ) +\n                      w_k[non_zero_theta[ok_log[num_ok_log -2]]] *( - 3 * log(theta[non_zero_theta[ok_log[num_ok_log - 1]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log - 1]]]) + \n                                                                      log(theta[non_zero_theta[ok_log[num_ok_log - 3]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log - 3]]]) - \n                                                                      2 * log(theta[non_zero_theta[ok_log[num_ok_log - 2]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log - 2]]]) ) ) ) / x - \n                  temp4[ok_log[num_ok_log - 1]] - \n                  (16*w_k[non_zero_theta[ok_log[num_ok_log - 1]]] + 8*w_k[non_zero_theta[ok_log[num_ok_log -2]]]) * lambda * log(x) / x / log(center_k[non_zero_theta[ok_log[num_ok_log - 1]]])}\n              \n                  g_end     <-  function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[num_ok_log]]] - 2*lambda * w_k[non_zero_theta[ok_log[num_ok_log -1]]] * (-3 * \n                                               log(theta[non_zero_theta[ok_log[num_ok_log]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log]]]) + \n                                               log(theta[non_zero_theta[ok_log[num_ok_log - 2]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log - 2]]]) - \n                                               2 * log(theta[non_zero_theta[ok_log[num_ok_log - 1]]]) / log(center_k[non_zero_theta[ok_log[num_ok_log - 1]]])   )) / x  -   \n                  temp4[ok_log[num_ok_log]] - 8*w_k[non_zero_theta[ok_log[num_ok_log - 1]]] * lambda*log(x)/x / log(center_k[non_zero_theta[ok_log[num_ok_log]]]) }  \n              \n            \n                  \n                  U_1 <- data$Sum_m_k[update_theta] - 2 * lambda * (2 * w_k[update_theta] * (-2 * log(theta[update_theta]) / log(center_k[update_theta]) - \n                                                                                               log(theta[plus_1]) /  log(center_k[plus_1]) - log(theta[minus_1]) / log(center_k[minus_1]) ) + \n                                                                      w_k[minus_1]*(-3 * log(theta[update_theta]) / log(center_k[update_theta]) + \n                                                                                      log(theta[minus_2]) / log(center_k[minus_2]) - 2 * log(theta[minus_1]) / log(center_k[minus_1])  ) + \n                                                                      w_k[plus_1]*(-2 * log(theta[plus_1]) / log(center_k[plus_1]) + log(theta[plus_2]) / log(center_k[plus_2]) - \n                                                                                     3 * log(theta[update_theta]) / log(center_k[update_theta])))\n                  \n                  U_2 <- (16*w_k[update_theta] + 8*w_k[minus_1] + 8*w_k[plus_1]) * lambda\n                  \n                  U_3 <- temp4[ok_log[-c(1,2,num_ok_log - 1,num_ok_log)]]\n                  \n                  \n              theta[non_zero_theta[ok_log[1]]] <- tryCatch(uniroot(g_1,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                   error = function(e) {return(theta[non_zero_theta[ok_log[1]]])})\n              \n              theta[non_zero_theta[ok_log[2]]] <- tryCatch(uniroot(g_2,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                   error = function(e) {return(theta[non_zero_theta[ok_log[2]]])})\n              #parallelization here\n              for (jj in 1:length(update_theta)) {\n                g <- function(x){U_1[jj]/x - U_2[jj]*log(x)/x / log(center_k[update_theta[jj]]) - U_3[jj]}\n                theta[update_theta[jj]] <- tryCatch(uniroot(g,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                    error = function(e) theta[update_theta[jj]])\n              }\n              theta[non_zero_theta[ok_log[num_ok_log - 1]]] <- tryCatch(uniroot(g_semiend,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                                 error = function(e) \n                                                                 {return(theta[non_zero_theta[ok_log[num_ok_log - 1]]])})\n              theta[non_zero_theta[ok_log[num_ok_log]]] <- tryCatch(uniroot(g_end,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                             error = function(e) {return(theta[non_zero_theta[ok_log[num_ok_log]]])})\n              \n              if (length(not_ok_log) > 0) \n                theta[non_zero_theta[not_ok_log]] <- data$Sum_m_k[non_zero_theta[not_ok_log]]/temp4[not_ok_log]  \n            } else if (2 == mode_reg_A) {\n              #mode_reg_A == 2  \n              # a little different, since there are terms from A_0 \n              g_1  <- function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[1]]] - 2 * u[2,1] * w_k[non_zero_theta[ok_log[2]]] * lambda * \n                   (- u[2,2] * log(theta[non_zero_theta[ok_log[2]]])   + \n                      u[2,3] * log(theta[non_zero_theta[ok_log[3]]])  - \n                      3 * u[2,1] * log(theta[non_zero_theta[ok_log[1]]])  ) ) / x -   \n                  temp4[ok_log[1]] - 8 * lambda * w_k[non_zero_theta[ok_log[2]]] * log(x) / x * u[2,1]^2}\n              \n              g_1_new <- function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[1]]] - 2 * u[2,1] * w_k[non_zero_theta[ok_log[2]]] * lambda * \n                   (- u[2,2] * log(theta[non_zero_theta[ok_log[2]]])   + \n                      u[2,3] * log(theta[non_zero_theta[ok_log[3]]])  - \n                      3 * u[2,1] * log(theta[non_zero_theta[ok_log[1]]])  ) + \n                      2 * lambda * w_k[non_zero_theta[not_ok_log]] * \n                      (log(theta[non_zero_theta[ok_log[1]]])  + log(theta[non_zero_theta[not_ok_log]]) )) / x -   \n                  temp4[ok_log[1]] - (8 * lambda * w_k[non_zero_theta[ok_log[2]]] * u[2,1]^2 + \n                                      4 * lambda * w_k[non_zero_theta[not_ok_log]])* log(x) / x }\n              \n              g_2 <- function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[2]]] - lambda * \n                   (-2 * u[2 , 2] * w_k[non_zero_theta[ok_log[2]]] * ( u[2,2] * log(theta[non_zero_theta[ok_log[2]]]) + \n                                                                       u[2,3] * log(theta[non_zero_theta[ok_log[3]]]) +  \n                                                                       u[2,1] * log(theta[non_zero_theta[ok_log[1]]]) ) +\n                      \n                      2 * u[3,2] * w_k[non_zero_theta[ok_log[3]]]*(- u[3,3] * log(theta[non_zero_theta[ok_log[3]]])  +\n                                                                   u[3, 4] * log(theta[non_zero_theta[ok_log[4]]]) - \n                                                                  3 * u[3,2] * log(theta[non_zero_theta[ok_log[2]]])  ) )) / x - \n                  \n                  temp4[ok_log[2]] + (-4 * u[2,2]^2 * w_k[non_zero_theta[ok_log[2]]] - \n                                      8 * u[3,2]^2 * w_k[non_zero_theta[ok_log[3]]]) * lambda * log(x) / x     }\n              \n              g_semiend <- function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[num_ok_log - 1]]] - lambda * \n                   (-2 * u[num_ok_log - 1, num_ok_log - 1] * w_k[non_zero_theta[ok_log[num_ok_log - 1]]] * \n                      ( u[num_ok_log - 1, num_ok_log - 1] * log(theta[non_zero_theta[ok_log[num_ok_log - 1]]]) + \n                          u[num_ok_log - 1, num_ok_log] * log(theta[non_zero_theta[ok_log[num_ok_log]]])  + \n                          u[num_ok_log - 1, num_ok_log -  2] * log(theta[non_zero_theta[ok_log[num_ok_log - 2]]]) )  +\n                     2 * u[num_ok_log - 2, num_ok_log - 1] * w_k[non_zero_theta[ok_log[num_ok_log -2]]] * \n                      ( - 3 * u[num_ok_log - 2, num_ok_log - 1]* log(theta[non_zero_theta[ok_log[num_ok_log - 1]]]) + \n                          u[num_ok_log - 2, num_ok_log - 3] * log(theta[non_zero_theta[ok_log[num_ok_log - 3]]])  - \n                          u[num_ok_log - 2, num_ok_log - 2] * log(theta[non_zero_theta[ok_log[num_ok_log - 2]]])  ) ) ) / x - \n                  temp4[ok_log[num_ok_log - 1]] - \n                  (4 * u[num_ok_log - 1, num_ok_log - 1]^2 * w_k[non_zero_theta[ok_log[num_ok_log - 1]]] + 8 * u[num_ok_log - 2, num_ok_log - 1] ^ 2 * \n                     w_k[non_zero_theta[ok_log[num_ok_log -2]]]) * lambda * log(x) / x }\n              \n              g_end     <-  function(x) {\n                (data$Sum_m_k[non_zero_theta[ok_log[num_ok_log]]] - \n                   2 * u [num_ok_log - 1, num_ok_log] * lambda * w_k[non_zero_theta[ok_log[num_ok_log -1]]] * \n                   (-3 * u [num_ok_log - 1, num_ok_log] * log(theta[non_zero_theta[ok_log[num_ok_log]]])  + \n                      u [num_ok_log - 1, num_ok_log - 2 ] * log(theta[non_zero_theta[ok_log[num_ok_log - 2]]])  - \n                      u [num_ok_log - 1, num_ok_log - 1] * log(theta[non_zero_theta[ok_log[num_ok_log - 1]]])   )) / x  -   \n                  temp4[ok_log[num_ok_log]] - \n                  8 * u [num_ok_log - 1, num_ok_log]^2 * w_k[non_zero_theta[ok_log[num_ok_log - 1]]] * lambda * log(x) / x }  \n              \n              \n              U_1 <- data$Sum_m_k[update_theta] - lambda * (- 2 * extract_u(update_k, update_k) * w_k[update_theta] * (\n                extract_u(update_k, update_k) * log(theta[update_theta]) + \n                  extract_u(update_k, update_k + 1) * log(theta[plus_1]) +\n                  extract_u(update_k, update_k - 1) * log(theta[minus_1]) ) +\n                  \n                  2 * extract_u(update_k - 1, update_k) * w_k[minus_1] * (\n                    -3 * extract_u(update_k - 1, update_k) * log(theta[update_theta]) + \n                      extract_u(update_k - 1, update_k - 2) * log(theta[minus_2]) - \n                      extract_u(update_k - 1, update_k - 1) * log(theta[minus_1]) ) + \n                  \n                  2 * extract_u(update_k + 1, update_k) * w_k[plus_1]* (\n                    - extract_u(update_k + 1, update_k + 1) * log(theta[plus_1]) + \n                      extract_u(update_k + 1, update_k + 2) * log(theta[plus_2])  - \n                      3 * extract_u(update_k + 1, update_k)* log(theta[update_theta]) )\n              )\n              \n              U_2 <- (4 * extract_u(update_k, update_k)^2 * w_k[update_theta] + 8 * extract_u(update_k - 1, update_k)^2 * w_k[minus_1] + \n                        8 * extract_u(update_k + 1, update_k)^2 * w_k[plus_1]) * lambda\n              U_3 <- temp4[ok_log[-c(1,2,num_ok_log - 1,num_ok_log)]]\n              \n            \n              \n              theta[non_zero_theta[ok_log[1]]] <- tryCatch(uniroot(g_1_new,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                           error = function(e) {return(theta[non_zero_theta[ok_log[1]]])})\n              \n              theta[non_zero_theta[ok_log[2]]] <- tryCatch(uniroot(g_2,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                           error = function(e) {return(theta[non_zero_theta[ok_log[2]]])})\n              #parallelization here\n              for (jj in 1:length(update_theta)) {\n              #jj <- length(update_theta)\n              g <- function(x){U_1[jj]/x - U_2[jj]*log(x)/x - U_3[jj]}\n               theta[update_theta[jj]] <- tryCatch(uniroot(g,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                   error = function(e) theta[update_theta[jj]])\n              }\n               theta[non_zero_theta[ok_log[num_ok_log - 1]]] <- tryCatch(uniroot(g_semiend,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                                        error = function(e) \n                                                                     {return(theta[non_zero_theta[ok_log[num_ok_log - 1]]])})\n               theta[non_zero_theta[ok_log[num_ok_log]]] <- tryCatch(uniroot(g_end,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                                    error = function(e) {return(theta[non_zero_theta[ok_log[num_ok_log]]])})\n               \n               if (length(not_ok_log) > 0) {\n                  #print(\"Update zero\")\n                  if (lambda <= 0) {\n                      theta[non_zero_theta[not_ok_log]] <- data$Sum_m_k[non_zero_theta[not_ok_log]]/temp4[not_ok_log] \n                  }else {\n                    g_0  <- function(x) {\n                      (data$Sum_m_k[non_zero_theta[not_ok_log]] - 2 * w_k[non_zero_theta[not_ok_log]] * lambda * \n                         (- log(theta[non_zero_theta[not_ok_log]]) - \n                            log(theta[non_zero_theta[ok_log[1]]]) )) / x -   \n                        temp4[not_ok_log] - 4 * lambda * w_k[non_zero_theta[not_ok_log]] * log(x) / x}\n                    theta[non_zero_theta[not_ok_log]] <- tryCatch(uniroot(g_0,interval = c(0.0000001,1000),tol = .Machine$double.eps)$root,\n                                                                  error = function(e) {return(theta[non_zero_theta[not_ok_log]])}) \n                  }\n                  \n                  }\n               }\n              #print(theta)\n              #print(cal_reg_A());\n            }\n          ### NORMALIZED THETA\n          #theta <- theta / theta[1];\n          #print(cal_reg_A());\n         }\n          if (TRUE == debug_PA) {\n              first_part  <- center_k != 0 & center_k <= 100\n              second_part <- center_k != 0 & center_k > 100\n              lm1         <- lm(log(theta[first_part]) ~ log(center_k[first_part]))\n              lm2         <- lm(log(theta[second_part]) ~ log(center_k[second_part]))\n              constant1   <- lm1$coefficients[1]\n              constant2   <- lm2$coefficients[1]\n              alpha_1     <- lm1$coefficients[2]\n              alpha_2     <- lm2$coefficients[2]\n              overal_alpha <- lm(log(theta[center_k != 0]) ~ log(center_k[center_k != 0]))$coefficients[2]\n              plot(center_k,theta,log = \"xy\", pch = 20,main = paste0(round(overal_alpha,2),\"-\",\n                                                                      round(alpha_1,2),\"-\",\n                                                                     round(alpha_2,2)))  \n              lines(center_k[first_part],exp(constant1) * center_k[first_part]^alpha_1)\n              lines(center_k[second_part],exp(constant2) * center_k[second_part]^alpha_2)\n          }\n        } else { # log-linear PA\n        .normalized_constant_alpha(normalized_const, alpha,PA_offset,data$node_degree,theta,f,data$offset_tk,offset)\n        time_non_zero     <- which(normalized_const != 0)\n        log_likelihood <- c(log_likelihood, sum(data$z_j[non_zero_f] * log(f[non_zero_f])) +\n                              alpha * sum(data$Sum_m_k[non_zero_theta] * log(theta[non_zero_theta])) -\n                              sum(data$m_t[time_non_zero] * log(normalized_const[time_non_zero])) + \n                              ((shape - 1) * (sum(log(f[non_zero_f]))) - rate * sum(f[non_zero_f])) + \n                              sum(data$offset_m_tk)*log(offset) + (shape - 1) * log(offset) - rate * offset)  \n        log_likelihood[length(log_likelihood)] <- log_likelihood[length(log_likelihood)] + data$Sum_m_k[1] * \n                                                   log(PA_offset);\n        \n          if ((TRUE == debug) && (length(log_likelihood) > 0)){\n              print(log_likelihood[length(log_likelihood)])\n              if (length(log_likelihood) > 1)\n                  if (log_likelihood[length(log_likelihood)] < log_likelihood[length(log_likelihood) - 1])\n                      print(\"Warning: Log likelihood decreased.\")  \n          }\n          break_flag <- FALSE\n          if (TRUE == auto_stop)\n              if (length(log_likelihood) > 1)\n                  tryCatch({if (abs(log_likelihood[length(log_likelihood)] - log_likelihood[length(log_likelihood) - 1]) / \n                           (abs(log_likelihood[length(log_likelihood) - 1]) + 1) < stop_cond)\n                  break_flag <- TRUE;},error = function(e) { #print(as.vector(normalized_const));print(f[non_zero_f]);\n                  #print(non_zero_f);\n                break_flag <- TRUE;})\n          if (break_flag)\n              break;   \n         #print(theta);\n         #flush.console();\n        # Remember here theta is always the degree sequence,i.e. we need to calculate the power alpha of this deg. seq.    \n\n          ##################### Update f ######################\n        \n         if (FALSE == only_PA)  {\n             .update_f_alpha(f,non_zero_f,alpha,PA_offset,data$node_degree,theta,data$z_j,normalized_const,data$m_t,shape,rate)\n             # update offset\n             # if (data$deg_thresh > 0)\n             # offset <- .update_offset_alpha(alpha,data$offset_tk, data$offset_m_tk, theta, normalized_const,data$m_t, shape,rate)\n         }\n         #####################  Update alpha #######################  \n         .normalized_constant_alpha(normalized_const, alpha,PA_offset, data$node_degree,theta,f,data$offset_tk,offset)\n         alpha     <- .update_alpha(non_zero_theta,\n                                    normalized_const,f, PA_offset,\n                                    theta,data$node_degree,data$m_t,data$Sum_m_k,data$offset_tk,offset) \n         #.normalized_constant_alpha(normalized_const, alpha,PA_offset, data$node_degree,theta,f,data$offset_tk,offset)\n         #PA_offset <- .update_PA_offset(normalized_const,f,data$node_degree,data$m_t,data$Sum_m_k,\n         #                                 data$offset_tk);\n         #print(alpha)\n         #.normalized_constant_alpha(normalized_const, alpha, PA_offset, data$node_degree,theta,f,data$offset_tk,offset)\n          alpha_series <- c(alpha_series,alpha)\n      }\n}\n    theta    <- theta^alpha\n    if (only_f == TRUE)\n        theta[1] <- PA_offset  \n    ########## End of Iteration ########################    \n    if (FALSE == break_flag)\n       print(paste0(\"End by reaching maximum number of iterations (\",max_iter,\")\")); \n    \n      if (normalized_f == TRUE) {\n          sum_f  <- sum(f)  \n          f      <- (length(f) + 1) * f / (sum_f + offset)\n          offset <- offset * (length(f) + 1) / (sum_f + offset)   \n          if ((FALSE == only_PA) || ((TRUE == only_PA) && (!is.null(true_f)))){\n            .normalized_constant(normalized_const,data$node_degree,theta,f,data$offset_tk,offset) \n          }\n          else normalized_const <- as.vector(data$n_tk[,non_zero_theta]%*%theta[non_zero_theta])\n      }\n       ##### Variance of f ####################\n       cov_f   <- rep(0,length(f))\n       if (FALSE == only_PA)\n           .cal_var_f(cov_f,non_zero_f,data$node_degree,theta,f,data$z_j,\n                     normalized_const,data$m_t,shape)\n     \n      # mode_reg_A = 0:\n      hessian_of_regularization <- function(theta){\n              n      <- length(theta)\n              result <- vector()\n              if (n - 2 >= 3){\n                  result <- c(result,2*w_k[non_zero_theta[2]]*((1-log(theta[1]))/theta[1]^2 + (2*log(theta[2]) - log(theta[3])) / theta[1]^2 ) )\n              \n                  result <- c(result,2*w_k[non_zero_theta[3]]*((1-log(theta[2]))/theta[2]^2 + (2*log(theta[3]) - log(theta[4])) / theta[2]^2 ) +\n                                 2*w_k[non_zero_theta[2]]*((2-2*log(theta[2]))/theta[2]^2 + (log(theta[3]) + log(theta[1])) / theta[2]^2 ))\n                  for (ii in 3:(n-2))\n                      result <- c(result,2*w_k[non_zero_theta[ii]]*((2-2*log(theta[ii]))/theta[ii]^2 + (log(theta[ii+1]) + log(theta[ii-1])) / theta[ii]^2 ) + \n                                         2*w_k[non_zero_theta[ii + 1]]*((1-log(theta[ii]))/theta[ii]^2 + (2*log(theta[ii+1]) - log(theta[ii+2])) / theta[ii]^2 ) +\n                                         2*w_k[non_zero_theta[ii-1]]*((1-log(theta[ii]))/theta[ii]^2 + (2*log(theta[ii-1]) - log(theta[ii-2])) / theta[ii]^2 ))\n                  ii <- n - 1\n                  result <- c(result, 2*w_k[non_zero_theta[ii]]*((2-2*log(theta[ii]))/theta[ii]^2 + (log(theta[ii+1]) + log(theta[ii-1])) / theta[ii]^2 ) +\n                                  2*w_k[non_zero_theta[ii-1]]*((1-log(theta[ii]))/theta[ii]^2 + (2*log(theta[ii-1]) - log(theta[ii-2])) / theta[ii]^2 ))\n                  ii <- n\n                  result <- c(result, 2*w_k[non_zero_theta[ii-1]]*((1-log(theta[ii]))/theta[ii]^2 + (2*log(theta[ii-1]) - log(theta[ii-2])) / theta[ii]^2 )) \n              }\n              return(w_k[non_zero_theta]*result)\n      }\n      \n      # mode_reg_A = 1:\n      hessian_of_regularization_log <- function(theta){\n          n      <- length(theta)\n          result <- vector()\n          if (n - 2 >= 3){\n              result <- c(result,2*w_k[non_zero_theta[ok_log[2]]]*((1 - log(theta[1]) / log(center_k[non_zero_theta[ok_log[1]]]) ) /theta[1]^2 + \n                                                                     (2*log(theta[2]) / log(center_k[non_zero_theta[ok_log[2]]]) - \n                                                                        log(theta[3])) / log(center_k[non_zero_theta[ok_log[3]]]) / theta[1]^2 ) )\n            \n              result <- c(result,2*w_k[non_zero_theta[ok_log[3]]]*((1 - log(theta[2]) / log(center_k[non_zero_theta[ok_log[2]]]) )/theta[2]^2 + \n                                                                   (2*log(theta[3]) / log(center_k[non_zero_theta[ok_log[3]]]) - log(theta[4]) / log(center_k[non_zero_theta[ok_log[4]]])) / theta[2]^2 ) +\n                          2*w_k[non_zero_theta[2]]*((2 - 2 * log(theta[2]) / log(center_k[non_zero_theta[ok_log[2]]]) )/theta[2]^2 + ( log(theta[3]) / log(center_k[non_zero_theta[ok_log[3]]]) + \n                                                                                                                                       log(theta[1]) / log(center_k[non_zero_theta[ok_log[1]]])  ) / theta[2]^2 ))\n             for (ii in 3:(n-2))\n                 result <- c(result,2*w_k[non_zero_theta[ok_log[ii]]]*((2 - 2 * log(theta[ii]) / log(center_k[non_zero_theta[ok_log[ii]]]) )/theta[ii]^2 + \n                                                                     (log(theta[ii + 1]) / log(center_k[non_zero_theta[ok_log[ii + 1]]]) + \n                                                                      log(theta[ii - 1]) / log(center_k[non_zero_theta[ok_log[ii - 1]]]) ) / theta[ii]^2 ) + \n                             2*w_k[non_zero_theta[ok_log[ii + 1]]]*((1 - log(theta[ii]) / log(center_k[non_zero_theta[ok_log[ii]]]) )/theta[ii]^2 + \n                                                                    (2 * log(theta[ii + 1] / log(center_k[non_zero_theta[ok_log[ii + 1]]])) - \n                                                                   log(theta[ii + 2]) / log(center_k[non_zero_theta[ok_log[ii + 2]]]) ) / theta[ii]^2 ) +\n                             2*w_k[non_zero_theta[ok_log[ii-1]]]*((1 - log(theta[ii]) / log(center_k[non_zero_theta[ok_log[ii]]]) )/theta[ii]^2 + \n                                                                  (2 * log(theta[ii - 1]) / log(center_k[non_zero_theta[ok_log[ii - 1]]]) - \n                                                                   log(theta[ii - 2]) / log(center_k[non_zero_theta[ok_log[ii - 2]]]) ) / theta[ii]^2 ))\n                 ii <- n - 1\n                 result <- c(result, 2 * w_k[non_zero_theta[ok_log[ii]]]*((2 - 2 * log(theta[ii]) / log(center_k[non_zero_theta[ok_log[ii]]]) )/theta[ii]^2 + \n                                                                          (log(theta[ii + 1]) / log(center_k[non_zero_theta[ok_log[ii + 1]]]) + \n                                                                           log(theta[ii - 1]) / log(center_k[non_zero_theta[ok_log[ii - 1]]])  ) / theta[ii]^2 ) +\n                            2*w_k[non_zero_theta[ok_log[ii-1]]]*((1 - log(theta[ii]) / log(center_k[non_zero_theta[ok_log[ii]]])) / theta[ii]^2 + \n                                                                   (2 * log(theta[ii - 1]) / log(center_k[non_zero_theta[ok_log[ii - 1]]]) - \n                                                                    log(theta[ii - 2]) / log(center_k[non_zero_theta[ok_log[ii - 2]]]) ) / theta[ii]^2 ))\n                 ii <- n\n                 result <- c(result, 2*w_k[non_zero_theta[ok_log[ii-1]]]*((1 - log(theta[ii]) / log(center_k[non_zero_theta[ok_log[ii]]]) )/theta[ii]^2 + \n                                                                        (2 * log(theta[ii - 1]) / log(center_k[non_zero_theta[ok_log[ii - 1]]]) - \n                                                                           log(theta[ii - 2]) / log(center_k[non_zero_theta[ok_log[ii - 2]]])  ) / theta[ii]^2 )) \n          }\n          return(w_k[non_zero_theta[ok_log]]*result)\n      }\n\n      # mode_reg_A = 2:\n      hessian_of_regularization_mode_2 <- function(theta){\n        n      <- length(theta)\n        result <- vector()\n        if (n >= 2){\n          result <- c(result, 2 * w_k[non_zero_theta[not_ok_log]] * (1 - log(theta[non_zero_theta[1]]) + log(theta[non_zero_theta[ok_log[1]]])) / theta[non_zero_theta[1]]^2) \n          \n          result <- c(result, - (-2 *  w_k[non_zero_theta[not_ok_log]] * log(theta[non_zero_theta[not_ok_log]]) - 2 *  w_k[non_zero_theta[not_ok_log]]  + \n                                  2 *  w_k[non_zero_theta[not_ok_log]] * log(theta[non_zero_theta[ok_log[1]]])  +  \n                                  2 *  w_k[non_zero_theta[ok_log[2]]] * u[2,1] * (u[2,3] * log(theta[non_zero_theta[ok_log[3]]]) -  u[2,2] * log(theta[non_zero_theta[ok_log[2]]])) - \n                                  2 *  w_k[non_zero_theta[ok_log[2]]] * u[2,1]^2 + 2 *  w_k[non_zero_theta[ok_log[2]]] * u[2,1]^2 * log(theta[non_zero_theta[ok_log[1]]]) ) / theta[non_zero_theta[ok_log[1]]]^2);\n          \n          result <- c(result, - (-2 *  w_k[non_zero_theta[ok_log[2]]] * (u[2,3] * log(theta[non_zero_theta[ok_log[3]]]) +  u[2,1] * log(theta[non_zero_theta[ok_log[1]]]))  * u[2,2] - \n                                  2 *  w_k[non_zero_theta[ok_log[2]]] * u[2,2]^2 + 2 *  w_k[non_zero_theta[ok_log[2]]] * u[2,2]^2 *  log(theta[non_zero_theta[ok_log[2]]]) + \n                                  2 *  w_k[non_zero_theta[ok_log[3]]] * (u[3,4] * log(theta[non_zero_theta[ok_log[4]]]) -  u[3,3] * log(theta[non_zero_theta[ok_log[3]]]))  * u[3,2] - \n                                  2 *  w_k[non_zero_theta[ok_log[3]]] * u[3,2]^2 +  2 *  w_k[non_zero_theta[ok_log[3]]] * u[3,2]^2 * log(theta[non_zero_theta[ok_log[2]]]) ) / theta[non_zero_theta[ok_log[2]]]^2);\n          m <- length(ok_log)\n          for (ii in 3:(m-2))\n            result <- c(result, - ( 2 *  w_k[non_zero_theta[ok_log[ii - 1]]] * ( - u[ii - 1,ii] + log(theta[non_zero_theta[ok_log[ii]]]) + u[ii - 1,ii - 2] * log(theta[non_zero_theta[ok_log[ii - 2]]]) -\n                                                                                   u[ii - 1, ii - 1] * log(theta[non_zero_theta[ok_log[ii - 1]]]))  * u[ii - 1,ii]  + \n                                    2 *  w_k[non_zero_theta[ok_log[ii + 1]]] * ( u[ii + 1,ii + 2] *  log(theta[non_zero_theta[ok_log[ii + 2]]]) -  u[ii + 1,ii] + log(theta[non_zero_theta[ok_log[ii]]]) -\n                                                                                  u[ii + 1,ii + 1] * log(theta[non_zero_theta[ok_log[ii + 1]]]))  * u[ii + 1,ii] -    \n                                    2 *  w_k[non_zero_theta[ok_log[ii]]] * ( u[ii,ii + 1] *  log(theta[non_zero_theta[ok_log[ii + 1]]]) +  u[ii,ii] - log(theta[non_zero_theta[ok_log[ii]]]) +\n                                                                             u[ii,ii - 1] * log(theta[non_zero_theta[ok_log[ii - 1]]]))  * u[ii,ii]  ) / theta[non_zero_theta[ok_log[ii]]]^2)\n                        \n          ii <- m - 1\n          result <- c(result, - ( - 2 *  w_k[non_zero_theta[ok_log[ii]]] * (u[ii,ii + 1] * log(theta[non_zero_theta[ok_log[ii + 1]]]) + u[ii,ii - 1] * log(theta[non_zero_theta[ok_log[ii - 1]]]) +\n                                                                                 u[ii, ii] - log(theta[non_zero_theta[ok_log[ii]]]))  * u[ii,ii]  + \n                                    2 *  w_k[non_zero_theta[ok_log[ii - 1]]] * ( - u[ii - 1, ii]  +  log(theta[non_zero_theta[ok_log[ii]]]) + u[ii - 1,ii - 2] *  log(theta[non_zero_theta[ok_log[ii - 2]]]) -  \n                                                                                   u[ii - 1,ii - 1] * log(theta[non_zero_theta[ok_log[ii - 1]]]) ) * u[ii - 1,ii]  ) / theta[non_zero_theta[ok_log[ii]]]^2) \n          ii <- m\n          result <- c(result, - (2 *  w_k[non_zero_theta[ok_log[ii - 1]]] * (- u[ii - 1, ii] +  log(theta[non_zero_theta[ok_log[ii]]]) + u[ii - 1,ii - 2] * log(theta[non_zero_theta[ok_log[ii - 2]]]) - \n                                                                                  u[ii - 1,ii - 1] * log(theta[non_zero_theta[ok_log[ii - 1]]]) ) * u[ii - 1,ii] / theta[non_zero_theta[ok_log[ii]]]^2 )) \n        }\n        return(result);\n        \n      }\n\n      #interpolation for PA function\n      #but only if (FALSE == only_f)\n    if ((FALSE == only_f) && (mode_f[1] != \"Log_linear\")) {  \n        if (TRUE == interpolate) {\n            theta_nonzero <- which(data$Sum_m_k != 0)\n            if ((only_f == TRUE) && ((mode_f[1] = \"Linear_PA\") || (mode_f[1] = \"Log_linear\"))) {\n                if (0 != PA_offset)    \n                    theta_nonzero <- c(1,theta_nonzero)  \n            }\n            if (length(theta_nonzero) > 0)\n                if (theta_nonzero[1] > 1) {\n                    theta[1:(theta_nonzero[1] - 1)]   <- theta[theta_nonzero[1]]  \n                #cov_bin[1:(theta_nonzero[1] - 1)] <- cov_bin[theta_nonzero[1]] \n                }\n            if (length(theta_nonzero) > 1) {\n                for (i in 1:(length(theta_nonzero) - 1))\n                    if (theta_nonzero[i+1] > theta_nonzero[i] + 1) {\n                        regress <- lm(c(log(theta[theta_nonzero[i]]),log(theta[theta_nonzero[i+1]]))~ \n                                      c(log(center_k[theta_nonzero[i]]),log(center_k[theta_nonzero[i+1]]))) \n                    for (j in (theta_nonzero[i] + 1):(theta_nonzero[i+1] - 1))\n                        theta[j] <- exp(log(center_k[j])*regress$coefficients[2] + \n                                        regress$coefficients[1])           \n                    }  \n            }\n            if (length(theta_nonzero) > 0)\n                if (theta_nonzero[length(theta_nonzero)] < length(theta))\n                    theta[(theta_nonzero[length(theta_nonzero)] + 1):length(theta)] <- \n                    theta[theta_nonzero[length(theta_nonzero)]]  \n        }\n    }\n\n    if (only_PA == FALSE) {\n        beg     <- which(center_k >= data$deg_thresh & theta != 0)[1]\n    } else beg <- which(theta != 0)[1]    \n    theta <- theta/theta[beg]\n   \n\n    if ((FALSE == only_PA) || ((TRUE == only_PA) && (!is.null(true_f)))){\n        .normalized_constant(normalized_const,data$node_degree,theta,f,data$offset_tk,offset) \n    }\n        else normalized_const <- as.vector(data$n_tk[,non_zero_theta]%*%theta[non_zero_theta])\n    ############# Calculate the variance of theta #####################\n    cov_bin1       <- rep(0,length(theta)) \n    #non_zero       <- which(theta != 0)\n    non_zero <- which(data$Sum_m_k > 0)\n    non_zero_theta <- non_zero\n    time_non_zero     <- which(normalized_const != 0)\n    if ((FALSE == only_PA) || ((TRUE == only_PA) && (!is.null(true_f)))) {\n      temp4  <- .coeff_var(data$node_degree, f, normalized_const,data$m_t,data$offset_tk, data$start_deg + data$G) \n      temp4 <- temp4[non_zero]\n    }\n   \n    else {\n      temp4 <- colSums(data$n_tk[time_non_zero,non_zero_theta]^2 * data$m_t[time_non_zero] / normalized_const[time_non_zero]^2)\n    }\n    if (0 == mode_reg_A) {\n        aa <- 1 / (data$Sum_m_k[non_zero_theta] /theta[non_zero_theta] ^ 2 + - temp4 + \n                   lambda * hessian_of_regularization(theta[non_zero_theta]))\n        bb <-  1 / (data$Sum_m_k[non_zero_theta] /theta[non_zero_theta] ^ 2 +  \n                   lambda * hessian_of_regularization(theta[non_zero_theta])) \n    }\n    else if (1 == mode_reg_A) {\n    # mode_reg_A = 1\n        upper_aa <- data$Sum_m_k[non_zero_theta] /theta[non_zero_theta] ^ 2 + - temp4 \n        upper_aa[ok_log] <- upper_aa[ok_log] + lambda * hessian_of_regularization_log(theta[non_zero_theta[ok_log]])\n        upper_bb <- data$Sum_m_k[non_zero_theta] /theta[non_zero_theta] ^ 2\n        upper_bb[ok_log] <- upper_bb[ok_log] + lambda * hessian_of_regularization_log(theta[non_zero_theta[ok_log]])\n        \n        aa <- 1 / (upper_aa)\n        bb <-  1 / (upper_bb)   \n    } else if (2 == mode_reg_A) {\n        upper_aa <- data$Sum_m_k[non_zero_theta] /theta[non_zero_theta] ^ 2 + - temp4 \n        #print(upper_aa)\n        #print(non_zero_theta)\n        #print(hessian_of_regularization_mode_2(theta))\n        upper_aa <- upper_aa + lambda * hessian_of_regularization_mode_2(theta)\n        upper_bb <- data$Sum_m_k[non_zero_theta] /theta[non_zero_theta] ^ 2\n        upper_bb <- upper_bb + lambda * hessian_of_regularization_mode_2(theta)\n        aa <- 1 / (upper_aa)\n        bb <-  1 / (upper_bb)    \n    }\n    \n     cov_bin1[non_zero_theta] <- ifelse(aa > 10^-10, aa, bb) \n     #print(cov_bin1)\n     cov_bin1[cov_bin1 == Inf] <- 0\n\n     cov_bin <- cov_bin1\n     var_log_bin  <- cov_bin/ifelse(theta != 0, theta^2,1)\n     upper_bin    <- exp(log(theta) + 2*sqrt(var_log_bin))\n     lower_bin    <- exp(log(theta) - 2*sqrt(var_log_bin))\n     \n\n     non_zero_center <- center2_k > 0 & theta > 0 &  var_log_bin > 0 \n     #non_zero_center <- theta > 0 \n     if ((FALSE == only_f) && (mode_f[1] != \"Log_linear\"))\n         alpha_center <- lm(log(theta[non_zero_center]) ~ log(center2_k[non_zero_center]))$coefficients[2]\n     else \n         alpha_center <- NULL   \n     ############# Return theta to A #####################################\n      A                           <- rep(0,data$deg.max)\n      cov                         <- rep(0,data$deg.max)   \n      weight_A                    <- rep(1,data$deg.max)\n      A[1:(data$start_deg + 1)]        <- theta[1:(data$start_deg + 1)] \n      cov[1:(data$start_deg + 1)]      <- cov_bin[1:(data$start_deg + 1)]\n      weight_A[1:(data$start_deg + 1)] <- 1\n      for (i in 1:data$G) {\n          weight_A[(data$begin_deg[i]:data$end_deg[i]) + 1] <- data$interval_length[i]             \n          A[(data$begin_deg[i]:data$end_deg[i]) + 1]        <- theta[data$start_deg + i]\n          cov[(data$begin_deg[i]:data$end_deg[i])+1]        <- cov_bin[data$start_deg + i] #* weight_A[data$begin_deg[i] + 1]\n      }\n      interval     <- 0:(length(A) - 1)\n      \n      #return(list(k = interval, A = A))\n      non_zero     <- which(A > 10^-20 & cov > 10^-20)\n      non_zero     <- non_zero[non_zero >= data$deg_thresh]\n      k_non_zero   <- interval[non_zero]\n    \n      A            <- A[non_zero] \n      #cc           <- exp(mean(log(k_non_zero[k_non_zero > 0])) - mean(log(A[A > 0])))\n      cc           <- 1\n      A            <- cc * A\n      weight_A     <- weight_A[non_zero]\n      cov          <- cc ^ 2 * cov[non_zero]  \n      ############### fitting A_k = k^alpha ##################\n      var_log     <- cov / (A ^ 2)\n      sd_log      <- sqrt(var_log)\n      log_A       <- log(A)\n      log_k       <- log(k_non_zero)\n      \n      if (((only_f == FALSE) && (mode_f[1] != \"Log_linear\")) && (length(k_non_zero) > 0))  {\n              if (0 == k_non_zero[1]) \n                  linear_fit  <- lm(log_A[-1] ~ log_k[-1] , weights = 1 / (weight_A[-1]*var_log[-1])) \n              else\n                  linear_fit  <- lm(log_A ~log_k , weights = 1 / (weight_A * var_log)) \n      }\n      else linear_fit <- list(coefficients=c(-1,-1))\n      names(linear_fit$coefficients) <- c(\"offset\",\"attachment exponent\")\n      upper_A       <- exp(log(A) + 2 * sd_log)\n      lower_A       <- exp(log(A) - 2 * sd_log)\n      \n      ##### Variance of f ####################\n    \n      #if (rate <= 1 & shape <= 1)\n      #   f[-non_zero_f] <- 0\n\n      f_new        <- rep(offset,data$N)\n      names(f_new) <- data$node_id\n\n      f_new[as.character(data$f_position)] <- f\n      cov_f_new                  <- rep(0,data$N)\n      names(cov_f_new) <- data$node_id\n      cov_f_new[as.character(data$f_position)] <- abs(cov_f)\n      non_zero_f          <- f_new > 10^-20 & cov_f_new > 10^-20\n    \n      upper_f             <- rep(0,data$N)\n      upper_f[non_zero_f] <- exp(log(f_new[non_zero_f]) + 2 * sqrt(cov_f_new[non_zero_f] / f_new[non_zero_f] ^ 2))\n\n      lower_f             <- rep(0,data$N)\n      lower_f[non_zero_f] <- exp(log(f_new[non_zero_f]) - 2 * sqrt(cov_f_new[non_zero_f] / f_new[non_zero_f] ^ 2))\n\n      if (mode_f[1] != \"Log_linear\")\n         alpha = linear_fit$coefficients[2]\n      else names(alpha) <- \"Estimated attachment exponent\"\n      result <- list(A           = A   ,          var_A        = cov,      linear_fit     = linear_fit, mode_f = mode_f[1], \n                     center_k = center_k, alpha_series = ifelse(rep(mode_f[1] == \"Log_linear\",length(alpha_series)),alpha_series,-1),\n                     theta = theta, upper_bin = upper_bin, lower_bin = lower_bin,\n                     k             = k_non_zero ,   weight_of_A  = weight_A, var_logA       = var_log,  #alpha_center = alpha_center,      \n                     upper_A       = upper_A,       lower_A      = lower_A,  alpha_theta = alpha_center,\n                     alpha          = alpha, true_A = true_A, true_f = true_f,\n                     var_bin = cov_bin, PA_offset = PA_offset, candidate_accept = candidate_accept,\n                     f             = f_new,         var_f        = cov_f_new, only_PA = only_PA, only_f = only_f,\n                   upper_f       = upper_f,       lower_f      = lower_f,  objective_value = log_likelihood, lambda = lambda, \n                   shape = shape, rate = rate, normalized_f = normalized_f, deg_threshold = data$deg_thresh,\n                   stop_cond = stop_cond, auto_lambda = auto_lambda, ratio = ratio, G = data$G,shape = shape, rate = rate, \n                   offset = offset)\n      class(result) <- \"PAFit\"\n      return(result)\n}\n",
    "created" : 1476085295383.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "50203281",
    "id" : "653122A2",
    "lastKnownWriteTime" : 1479963369,
    "path" : "~/Dropbox/1- Program/PAFit/PAFit/R/PAFit.R",
    "project_path" : "R/PAFit.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}