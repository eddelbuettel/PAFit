{
    "contents" : "//// Cpp functions 2015-3-11 Thong Pham\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::plugins(\"cpp11\")]]\n\ndouble my_zeroin(double ax,double bx,std::function <double (double)> f,double tol,long max_iter)  ;\n\n// [[Rcpp::export(\".normalized_constant\")]]\nint normalized_constant(      NumericVector& norm, \n                        const NumericMatrix& degree, \n                        const NumericVector& theta,\n                        const NumericVector& f, \n                        const NumericMatrix& offset_tk,\n                        const double&        offset\n                        ) {\n    long T = degree.nrow();     // number of time-steps\n    long N = degree.ncol();     // number of nodes\n    long K = offset_tk.ncol();  // maximum degree\n    #pragma omp parallel for \n    for (long i = 0; i < T; i++) {\n        double total = 0; \n        for (long j = 0; j < N; j++)\n            if (degree(i,j) >= 0) {\n                total += theta(degree(i,j))*f(j);\n            }\n        for (long k = 0; k < K; ++k) {\n            //printf(\"%f\",offset_tk(i,k));\n            total += offset * offset_tk(i,k)*theta(k);\n        }\n        norm(i) = total;\n    }\n    return 0;\n}\n\n// [[Rcpp::export(\".normalized_constant_alpha\")]]\nint normalized_constant_alpha(      NumericVector& norm,\n                              const double       & alpha,   \n                              const double       & PA_offset,  \n                              const NumericMatrix& degree, \n                              const NumericVector& theta,\n                              const NumericVector& f, \n                              const NumericMatrix& offset_tk,\n                              const double&        offset) {\n  long T = degree.nrow();     // number of time-steps\n  long N = degree.ncol();     // number of nodes\n  long K = offset_tk.ncol();  // maximum degree \n  #pragma omp parallel for\n  for (long i = 0; i < T; i++) {\n    double total = 0;\n    for (long j = 0; j < N; j++)\n      if (degree(i,j) >= 0) {\n          if  (degree(i,j) > 0) \n              total += (pow(theta.at(degree.at(i,j)),alpha)) * f.at(j);\n          else \n              total += PA_offset * f.at(j);  \n      }\n      for (long k = 1; k < K; ++k)\n          total += offset_tk.at(i,k) * pow(theta.at(k),alpha);\n      total += offset_tk.at(i,0) * PA_offset;\n      norm.at(i) = total;\n  }\n  return 0;\n}\n// [[Rcpp::export(\".get_stats\")]]\nint get_stats(CharacterVector    & time_stamp,\n              CharacterVector    & unique_stamp,\n              const NumericVector& in_node, \n              const NumericVector& out_node,\n              const NumericVector& all_node,\n              const NumericVector& ok_node,\n              const NumericVector& bin_vector,\n              const long max_node_id,\n              const int  undirected,\n              const int  only_PA,\n              CharacterVector& time_vector,\n              NumericVector& Sum_m_k, \n              NumericMatrix& n_tk,\n              NumericVector& m_tk,\n              NumericVector& m_t,\n              NumericMatrix& offset_tk, \n              NumericVector& z_j, \n              NumericMatrix& node_degree,\n              NumericMatrix& offset_m_tk,\n              const int only_true_deg) {\n  long N     = all_node.size(); \n  long N_new = ok_node.size();\n  long T     = time_vector.size();\n  long K     = n_tk.ncol();\n  std::vector<long> node_array(max_node_id + 1,0); //the index used when indexing all arrays whose length is N\n  std::vector<int>  ok_array(max_node_id + 1,0);   //boolean check whether a node is used or not  \n  std::vector<int>  is_appear(N,0);\n  std::vector<int>  appear_onestep(N,0);\n  std::vector<long> ok_index(max_node_id + 1,0);//the index used when indexing all arrays whose length is N_new\n  std::vector<long> degree_vector(N,-1);\n  std::vector<long> degree_vector_onestep(N,-1);\n  std::vector<long> n_tk_vector(K,0);\n  std::vector<long> m_tk_vector(K,0);\n  std::vector<long> z_j_vector(N_new,0);\n  std::vector<long> offset_tk_vector(K,0);\n  std::vector<long> offset_m_tk_vector(K,0);\n  \n  \n  for (long i = 0; i < N; ++ i) {\n      node_array[all_node(i)] = i; \n  }\n  for (long i = 0; i < N_new; ++ i) {\n      ok_array[ok_node(i)] = 1; \n      ok_index[ok_node(i)] = i;\n     \n  }\n  long t  = 0;\n  long edge_count = 0;\n\n  while ((t < T)) {\n      checkUserInterrupt();  \n      if (t > 0)  {\n          if (0 == only_PA) { \n              for (long j = 0; j < ok_node.size(); ++ j) {\n                  if (degree_vector.at(node_array.at(ok_node(j))) >= 0) {\n                      node_degree(t - 1,ok_index.at(ok_node(j))) = bin_vector(degree_vector.at(node_array.at(ok_node(j))));\n                  }else {\n                      node_degree(t - 1,ok_index.at(ok_node(j))) = -1;\n                  }\n              }\n          }\n          if (0 == only_true_deg)\n              for (long k = 0; k < K; ++k) {\n                  n_tk(t - 1,k)          = n_tk_vector.at(k);\n                  if (0 == only_PA) {  \n                      offset_tk(t - 1,k)   = offset_tk_vector.at(k);\n                      offset_m_tk(t - 1,k) = offset_m_tk_vector.at(k);  \n                      offset_m_tk_vector.at(k) = 0;\n                  }\n              }\n      }    \n      if (0 == only_true_deg)\n          for (long k = 0; k < K; ++k)\n              m_tk_vector.at(k) = 0;\n      \n      if (0 == only_true_deg)\n          if (0 == only_PA)      \n              for (long j = 0; j < N_new; ++j)\n                  z_j_vector.at(j) = 0;    \n      \n      while ((edge_count < in_node.size()) && (time_stamp(edge_count) == time_vector(t))) {\n\n          long in_node_ind  = node_array.at(in_node(edge_count)); \n           long out_node_ind = node_array.at(out_node(edge_count)); \n          // consider the in-node first\n          //the in-node has not appeared in the previous time step\n          if (0 == is_appear[in_node_ind]) {\n              //the in-node has not appeared in previous edges of the current time step\n              if (0 == appear_onestep.at(in_node_ind)) { \n                  appear_onestep.at(in_node_ind)  = 1;\n                  degree_vector.at(in_node_ind)   = 1;\n                  //appear_onestep_in.at(in_node_ind)  = 1;\n                  if (0 == only_true_deg)\n                      ++n_tk_vector.at(bin_vector(degree_vector.at(in_node_ind))); \n                  if (0 == only_true_deg)\n                      if ((0 == only_PA) && (0 == ok_array.at(in_node(edge_count))))   \n                          ++offset_tk_vector.at(bin_vector(degree_vector.at(in_node_ind))); \n              \n              }\n              else { //the in-node has already appeared in some edges of the current time step\n                  if (0 == only_true_deg)    \n                      if ((0 == only_PA)&& (0 == ok_array.at(in_node(edge_count))))    \n                          --offset_tk_vector.at(bin_vector(degree_vector.at(in_node_ind))); \n                  if (0 == only_true_deg)\n                      --n_tk_vector.at(bin_vector(degree_vector.at(in_node_ind))); \n                  ++degree_vector.at(in_node_ind); \n                  if (0 == only_true_deg)\n                      ++n_tk_vector.at(bin_vector(degree_vector.at(in_node_ind))); \n                  if (0 == only_true_deg)\n                      if ((0 == only_PA) && (0 == ok_array.at(in_node(edge_count))))   \n                          ++offset_tk_vector.at(bin_vector(degree_vector.at(in_node_ind))); \n              }     \n        } // the in-node is already appeared in the previous time-step\n        else { \n            if (0 == only_true_deg)  \n                if ((0 == only_PA) && (1 == ok_array.at(in_node(edge_count))))\n                    z_j(ok_index.at(in_node(edge_count)))++;\n            if (0 == only_true_deg)    \n               ++m_tk_vector.at(bin_vector(degree_vector_onestep.at(in_node_ind))); \n            if (0 == only_true_deg)\n               if ((0 == only_PA) && (0 == ok_array.at(in_node(edge_count))))\n                   ++offset_m_tk_vector.at(bin_vector(degree_vector_onestep.at(in_node_ind)));         \n            if (0 == only_true_deg)\n                --n_tk_vector.at(bin_vector(degree_vector.at(in_node_ind)));\n            if (0 == only_true_deg)\n                if ((0 == only_PA) && (0 == ok_array.at(in_node(edge_count)))) {                  \n                    -- offset_tk_vector.at(bin_vector(degree_vector.at(in_node_ind)));        \n               }\n           ++degree_vector.at(in_node_ind);\n           if (0 == only_true_deg)      \n               ++n_tk_vector.at(bin_vector(degree_vector.at(in_node_ind))); \n           if (0 == only_true_deg)\n               if ((0 == only_PA) && (0 == ok_array.at(in_node(edge_count)))) {                       \n                   ++offset_tk_vector.at(bin_vector(degree_vector.at(in_node_ind)));    \n               }\n        }\n      //consider next the Out node\n      //the out node has not appeared in the previous time step\n      if (0 == is_appear.at(out_node_ind)) {\n          //the network is undirected, so this out_node is also counted\n          if (1 == undirected) {\n              if (0 == appear_onestep.at(out_node_ind)) {\n                  degree_vector.at(out_node_ind)   = 1;  \n                   if (0 == only_true_deg) \n                       ++n_tk_vector.at(bin_vector(degree_vector.at(out_node_ind)));  \n                   if (0 == only_true_deg)\n                       if ((0 == only_PA) && (0 == ok_array.at(out_node(edge_count))))\n                           ++offset_tk_vector.at(bin_vector(degree_vector.at(out_node_ind)));     \n              }\n              else {\n                  if (0 == only_true_deg)  \n                      if ((0 == only_PA) && (0 == ok_array.at(out_node(edge_count)))) \n                          --offset_tk_vector.at(bin_vector(degree_vector.at(out_node_ind))); \n                  if (0 == only_true_deg)    \n                      --n_tk_vector.at(bin_vector(degree_vector.at(out_node_ind)));    \n                  degree_vector.at(out_node_ind)   = 1;   \n                  if (0 == only_true_deg)\n                      ++n_tk_vector.at(bin_vector(degree_vector.at(out_node_ind)));   \n                  if (0 == only_true_deg)\n                      if ((0 == only_PA) && (0 == ok_array.at(out_node(edge_count)))) \n                          ++offset_tk_vector.at(bin_vector(degree_vector.at(out_node_ind))); \n              }\n          }\n          //the network is directed, so this out_node is not counted\n          else {\n               if (0 == appear_onestep.at(out_node_ind)) { \n                  degree_vector.at(out_node_ind)   = 0; \n                  if (0 == only_true_deg)\n                      ++n_tk_vector.at(bin_vector(degree_vector.at(out_node_ind)));\n                  if (0 == only_true_deg)\n                      if ((0 == only_PA) && (0 == ok_array.at(out_node(edge_count)))) {                       \n                          ++offset_tk_vector.at(bin_vector(degree_vector.at(out_node_ind))); \n                      }\n              }    \n          }\n          appear_onestep.at(out_node_ind)       = 1;\n      } \n      // the out node is already appeared in the previous time-step\n      else {\n           //the network is undirected, so this out_node is also counted  \n          if (1 == undirected) {  \n              if (0 == only_true_deg)  \n                  if ((0 == only_PA) && (0 == ok_array.at(out_node(edge_count)))) {                  \n                      -- offset_tk_vector.at(bin_vector(degree_vector.at(out_node_ind)));        \n                  }\n              if (0 == only_true_deg)    \n                  if ((0 == only_PA) && (1 == ok_array.at(out_node(edge_count))))\n                      z_j(ok_index.at(out_node(edge_count)))++;\n              if (0 == only_true_deg)    \n                  ++m_tk_vector.at(bin_vector(degree_vector_onestep.at(out_node_ind))); \n              if (0 == only_true_deg)\n                  if ((0 == only_PA) && (0 == ok_array.at(out_node(edge_count))))\n                      ++offset_m_tk_vector.at(bin_vector(degree_vector_onestep.at(out_node_ind)));\n              if (0 == only_true_deg)    \n                  --n_tk_vector.at(bin_vector(degree_vector.at(out_node_ind)));\n              \n              ++degree_vector.at(out_node_ind);\n              \n              if (0 == only_true_deg)\n                  ++n_tk_vector.at(bin_vector(degree_vector.at(out_node_ind))); \n              \n              if (0 == only_true_deg)\n                  if ((0 == only_PA) && (0 == ok_array.at(out_node(edge_count)))) {                  \n                      -- offset_tk_vector.at(bin_vector(degree_vector.at(out_node_ind)));        \n                  }\n          }\n      }\n      ++edge_count; \n     }\n  if (0 == only_true_deg)\n      if (t > 0)  {\n          for (long k = 0; k < K; ++k) {\n              m_tk(t - 1,k)     = m_tk_vector.at(k);\n              Sum_m_k(k)       += m_tk_vector.at(k);\n              m_t(t - 1)       += m_tk_vector.at(k);\n          \n          }\n          if (0 == only_PA) { \n              for (long i = 0; i < N_new; ++i) {\n                  z_j(i) += z_j_vector.at(i);\n              } \n          for (long k = 0; k < K; ++k) {\n              offset_m_tk(t - 1,k) = offset_m_tk_vector.at(k);      \n          }\n          }\n      }\n     t++;\n    \n     for (long n = 0; n < (long) degree_vector.size(); ++n)\n         degree_vector_onestep.at(n) = degree_vector.at(n);\n     for (long i = 0; i < (long) is_appear.size(); ++i) {\n         is_appear.at(i) = appear_onestep.at(i); \n         //appear_onestep.at(i)     = 0;\n         //appear_onestep_in.at(i)  = 0;\n         //appear_onestep_out.at(i) = 0;\n     }\n}\n    return 0;\n}\n// [[Rcpp::export(\".update_f\")]]\nint update_f(      NumericVector& f, \n             const NumericVector& non_zero_f,\n             const NumericMatrix& degree, \n             const NumericVector& theta, \n             const NumericVector& z_j,\n             const NumericVector& normalized_const, \n             const NumericVector& m_t, \n             const double         shape, \n             const double         rate,\n             const double         offset) {\n    long T        = degree.nrow();        // number of time-steps\n    long N_nozero = non_zero_f.size();   // number of nodes\n    #pragma omp parallel for\n    for (long j = 0; j < N_nozero; j++) {\n        double total = 0;\n        for (long i = 0; i < T; i++)\n            if ((degree(i,non_zero_f(j) - 1) >= 0) && (normalized_const(i) != 0)) {\n                total += m_t(i) / normalized_const(i) * theta(degree(i,non_zero_f(j) - 1));\n            }\n    if (z_j(non_zero_f(j) - 1) + shape - 1 <= 0)\n        f(non_zero_f(j) - 1) = offset;\n    else \n        f(non_zero_f(j) - 1) = (z_j(non_zero_f(j) - 1) + shape - 1)/(total + rate);\n    }\n    return 0;\n}\n\n// [[Rcpp::export(\".update_offset\")]]\ndouble update_offset(\n                   const NumericMatrix& offset_n_tk,\n                   const NumericMatrix& offset_m_tk, \n                   const NumericVector& theta, \n                   const NumericVector& normalized_const, \n                   const NumericVector& m_t, \n                   const double         shape, \n                   const double         rate) {\n  long T        = offset_n_tk.nrow();        // number of time-steps\n  long K        = offset_n_tk.ncol();\n  double total1 = 0;\n  double total2 = 0;\n  double offset = 1;  \n  #pragma omp parallel for reduction(+:total1, total2) \n  for (long i = 0; i < T; i++) {\n      for (long k = 0; k < K; k++) {  \n      if (normalized_const(i) != 0) \n          total1 += m_t(i) / normalized_const(i) * offset_n_tk(i,k) * theta(k);\n      total2 += offset_m_tk(i,k);  \n      }\n  }\n  //std::cout << \"total 2: \" << total2 << \"; Total 1: \\n\" << total1 << \"\\n\";\n  //std::cout << \"shape: \" << shape << \"; rate: \\n\" << rate << \"\\n\";\n  if (total2 + shape - 1 > 0)\n      offset = (total2 + shape - 1.0)/(total1 + rate);\n  //printf(\"%f \",offset);\n  \n  //std::cout << \"offset in C: \" << offset << \"\\n\";\n  return offset;\n}\n\n// [[Rcpp::export(\".update_offset_alpha\")]]\ndouble update_offset_alpha( \n                         const double       & alpha,       \n                         const NumericMatrix& offset_n_tk,\n                         const NumericMatrix& offset_m_tk, \n                         const NumericVector& theta, \n                         const NumericVector& normalized_const, \n                         const NumericVector& m_t, \n                         const double         shape, \n                         const double         rate) {\n  long T        = offset_n_tk.nrow();        // number of time-steps\n  long K        = offset_n_tk.ncol();\n  double total1 = 0;\n  double total2 = 0;\n  double offset = 0;\n#pragma omp parallel for reduction(+:total1, total2) \n  for (long i = 0; i < T; i++) {\n    for (long k = 0; k < K; k++)  \n      if (normalized_const(i) != 0) {\n        total1 += m_t(i) / normalized_const(i) * offset_n_tk(i,k) * pow(theta.at(k),alpha);\n        total2 += offset_m_tk(i,k);  \n      }\n  }\n  offset = (total2 + shape - 1)/(total1 + rate);\n  \n  return offset;\n}\n\n\n// [[Rcpp::export(\".update_f_alpha\")]]\nint update_f_alpha(      NumericVector& f, \n                   const NumericVector& non_zero_f,\n                   const double       & alpha,\n                   const double       & PA_offset,\n                   const NumericMatrix& degree, \n                   const NumericVector& theta, \n                   const NumericVector& z_j,\n                   const NumericVector& normalized_const, \n                   const NumericVector& m_t, \n                   const double         shape, \n                   const double         rate\n) {\n  long T        = degree.nrow();        // number of time-steps\n  long N_nozero = non_zero_f.size();   // number of nodes\n  #pragma omp parallel for\n  for (long j = 0; j < N_nozero; j++) {\n    double total = 0;\n    for (long i = 0; i < T; i++)\n        if ((degree.at(i,non_zero_f(j) - 1) >= 0) && (normalized_const.at(i) != 0)) {\n            if (degree(i,j) > 0)   \n                total += m_t.at(i) / normalized_const.at(i) * (pow(theta.at(degree.at(i,non_zero_f.at(j) - 1)),alpha));\n             else \n                 total += m_t.at(i) / normalized_const.at(i) * (PA_offset);   \n        }\n        if (z_j(non_zero_f(j) - 1) + shape - 1 <= 0)\n            f(non_zero_f(j) - 1) = 0;\n        else \n            f.at(non_zero_f.at(j) - 1) = (z_j.at(non_zero_f.at(j) - 1) + shape - 1)/(total + rate);\n  }\n  return 0;\n}\n\n// [[Rcpp::export(\".update_alpha\")]]\ndouble update_alpha(\n                 const NumericVector& non_zero_theta,  \n                 const NumericVector& norm,\n                 const NumericVector& f, \n                 const double       & PA_offset,\n                 const NumericVector& theta,\n                 const NumericMatrix& degree, \n                 const NumericVector& m_t,\n                 const NumericVector& Sum_m_k,\n                 const NumericMatrix& offset_tk,\n                 const double&        offset\n) {\n  long T = degree.nrow();     // number of time-steps\n  long N = degree.ncol();     // number of nodes\n  long K = offset_tk.ncol();  // maximum degree \n  long length_theta = theta.size();\n  NumericVector f_sum(length_theta);\n\n  for (long t = 0; t < T; t++) \n      for (long i = 0; i < N; ++i) {\n      if ((degree(t,i) > 0) && (norm(t) != 0)){\n        f_sum.at(degree(t,i)) += m_t.at(t)*f.at(i)/norm.at(t);\n      }\n  }\n  for (long t = 0; t < T; t++) \n      for (long k = 0; k < K; ++k) {\n          if ((degree(t,k) > 0) && (norm(t) != 0) ){\n              f_sum.at(k) += offset_tk(t,k) * m_t.at(t) * offset/norm.at(t);\n          }\n  }\n\n \n  auto f_1 = [&](double x) {\n      double temp = 0;\n      double first  = 0;\n    for(long k = 0; k <Sum_m_k.size(); ++k)\n      for (long k = 0; k < non_zero_theta.size(); ++k) {\n          temp += log(theta.at(non_zero_theta.at(k) - 1)) * pow(theta.at(non_zero_theta.at(k) - 1),x) *\n              f_sum.at(non_zero_theta.at(k) - 1);\n          if (theta.at(non_zero_theta.at(k) - 1) > 0)\n          first += Sum_m_k.at(k) * log(theta.at(non_zero_theta.at(k) - 1)) * pow(theta.at(non_zero_theta.at(k) - 1),x) / \n                   (pow(theta.at(non_zero_theta.at(k) - 1),x));  \n      }\n      return(first - temp);};\n  double alpha = my_zeroin(0,2,f_1,DBL_EPSILON,500);    \n  //printf(\"alpha inside C: %f\\n\",alpha);    \n  return alpha;\n}\n\n\n// [[Rcpp::export(\".update_PA_offset\")]]\ndouble update_PA_offset(\n    const NumericVector& norm,\n    const NumericVector& f, \n    const NumericMatrix& degree, \n    const NumericVector& m_t,\n    const NumericVector& Sum_m_k,\n    const NumericMatrix& offset_tk) {\n  long T = degree.nrow();     // number of time-steps\n  long N = degree.ncol();     // number of nodes\n //long K = offset_tk.ncol();  // maximum degree \n  double second_temp = 0;\n  \n  for (long t = 0; t < T; t++) \n    for (long i = 0; i < N; ++i) {\n      if ((degree(t,i) == 0) && (norm(t) != 0)){\n        second_temp += m_t.at(t)*f.at(i)/norm.at(t);\n      }\n    }\n  for (long t = 0; t < T; t++) \n      second_temp += offset_tk(t,0) * m_t.at(t) /norm.at(t);\n  \n  double result = Sum_m_k.at(0) * 1.0 / second_temp;\n  return result;\n\n}\n\n// [[Rcpp::export(\".coeff_theta\")]]\nNumericVector coeff_theta( const NumericMatrix& degree,  \n                           const NumericVector& f,\n                           const NumericVector& normalized_const,  \n                           const NumericVector& m_t, \n                           const int            length_theta\n                           ) {\n    int nrow = degree.nrow();\n    int ncol = degree.ncol();\n    NumericVector total(length_theta);\n    //#pragma omp parallel \n    //{\n    NumericVector total_temp(length_theta);\n    for (int j = 0; j < length_theta; ++j) {\n        total_temp[j] = 0;\n    } \n    //#pragma omp for\n    for (int j = 0; j < ncol; j++) {\n        for (int i = 0; i < nrow; i++)\n           if ((degree(i,j) >= 0) && (normalized_const(i) != 0)) {\n                total[degree(i, j)] += f(j)* m_t(i) / normalized_const(i) ;\n            }\n    }\n    //#pragma omp critical\n    //{\n    //for (int j = 0; j < length_theta; ++j)\n    //    total[j] += total_temp[j];\n    //}\n   // }\n    return total;\n}\n\n// [[Rcpp::export(\".coeff_var\")]]\nNumericVector coeff_var(const NumericMatrix& degree,  \n                        const NumericVector& f,\n                        const NumericVector& normalized_const,\n                        const NumericVector& m_t,\n                        const NumericMatrix& offset, \n                        const int            length_theta) {\n    int nrow = degree.nrow();\n    int ncol = degree.ncol();\n    NumericMatrix temp(nrow,length_theta);\n\n    NumericVector total(length_theta);\n\n    for (int j = 0; j < ncol; j++) {\n        for (int t = 0; t < nrow; t++)\n           if (degree(t,j) >= 0) {\n                temp(t,degree(t,j)) += f(j);\n            }\n    }\n    #pragma omp parallel for\n    for (int k = 0; k < length_theta; k++) {\n        for (int t = 0; t < nrow; t++)\n            if (normalized_const[t] != 0)\n                total(k) += pow(temp(t,k) + offset(t,k),2)* m_t(t) / pow(normalized_const(t),2);\n    }\n    return total;\n}\n\n// [[Rcpp::export(\".cal_var_f\")]]\nint cal_var_f(      NumericVector& cov_f, \n              const NumericVector& non_zero_f,\n              const NumericMatrix& degree,\n              const NumericVector& theta,\n              const NumericVector& f,\n              const NumericVector& z_j,\n              const NumericVector& normalized_const,\n              const NumericVector& m_t, \n              const double         shape) {\n    int T    = degree.nrow();\n    int N    = non_zero_f.size();\n    #pragma omp parallel for\n    for (int j = 0; j < N; j++) {\n        double total = 0;\n        for (int i = 0; i < T; i++)\n            if ((degree(i,non_zero_f(j) - 1) >= 0) && (normalized_const(i) != 0)) {\n                total += m_t(i) / pow(normalized_const(i),2) * pow(theta(degree(i,non_zero_f(j) - 1)),2);\n            }\n          cov_f(j) = 1/(z_j(non_zero_f(j) - 1)/pow(f(non_zero_f(j) - 1),2) + - total +\n                     (shape - 1)*pow(f(non_zero_f(j) - 1),2));\n    }\n    return 0;\n}\n\n\ndouble my_zeroin(double ax,double bx,std::function <double (double)> f,double tol,long max_iter)    /* An estimate to the root\t*/\n{\n  double a,b,c;\t\t\t\t/* Abscissae, descr. see above\t*/\n  double fa;\t\t\t\t/* f(a)\t\t\t\t*/\n  double fb;\t\t\t\t/* f(b)\t\t\t\t*/\n  double fc;\t\t\t\t/* f(c)\t\t\t\t*/\n  \n  a = ax;  b = bx;  fa = f(a);  fb = f(b);\n  c = a;   fc = fa;\n  long count = 0;\n  for(;;)\t\t/* Main iteration loop\t*/\n  { count++;\n    if (count > max_iter)\n      return b;\n    double prev_step = b-a;\t\t/* Distance from the last but one*/\n    /* to the last approximation\t*/\n    double tol_act;\t\t\t/* Actual tolerance\t\t*/\n    double p;      \t\t\t/* Interpolation step is calcu- */\n    double q;      \t\t\t/* lated in the form p/q; divi- */\n    /* sion operations is delayed   */\n    /* until the last moment\t*/\n    double new_step;      \t\t/* Step at this iteration       */\n    \n    if( fabs(fc) < fabs(fb) )\n    {                         \t\t/* Swap data for b to be the \t*/\n    a = b;  b = c;  c = a;          /* best approximation\t\t*/\n    fa=fb;  fb=fc;  fc=fa;\n    }\n    tol_act = 2*LDBL_EPSILON*fabs(b) + tol/2;\n    new_step = (c-b)/2;\n    \n    if( fabs(new_step) <= tol_act || fb == (double)0 )\n      return b;\t\t\t\t/* Acceptable approx. is found\t*/\n    \n    /* Decide if the interpolation can be tried\t*/\n    if( fabs(prev_step) >= tol_act\t/* If prev_step was large enough*/\n    && fabs(fa) > fabs(fb) )\t/* and was in true direction,\t*/\n    {\t\t\t\t\t/* Interpolatiom may be tried\t*/\n    double t1,cb,t2;\n      cb = c-b;\n      if( a==c )\t\t\t/* If we have only two distinct\t*/\n      {\t\t\t\t/* points linear interpolation \t*/\n    t1 = fb/fa;\t\t\t/* can only be applied\t\t*/\n    p = cb*t1;\n    q = 1.0 - t1;\n      }\n      else\t\t\t\t/* Quadric inverse interpolation*/\n      {\n        q = fa/fc;  t1 = fb/fc;  t2 = fb/fa;\n        p = t2 * ( cb*q*(q-t1) - (b-a)*(t1-1.0) );\n        q = (q-1.0) * (t1-1.0) * (t2-1.0);\n      }\n      if( p>(double)0 )\t\t/* p was calculated with the op-*/\n    q = -q;\t\t\t/* posite sign; make p positive\t*/\n    else\t\t\t\t/* and assign possible minus to\t*/\n    p = -p;\t\t\t/* q\t\t\t\t*/\n    \n    if( p < (0.75*cb*q-fabs(tol_act*q)/2)\t/* If b+p/q falls in [b,c]*/\n    && p < fabs(prev_step*q/2) )\t/* and isn't too large\t*/\n    new_step = p/q;\t\t\t/* it is accepted\t*/\n    /* If p/q is too large then the\t*/\n    /* bissection procedure can \t*/\n    /* reduce [b,c] range to more\t*/\n    /* extent\t\t\t*/\n    }\n    \n    if( fabs(new_step) < tol_act )\t/* Adjust the step to be not less*/\n    {\n    if ( new_step > (double)0 ) {\t/* than tolerance\t\t*/\n    new_step = tol_act;\n    } else {\n          new_step = -tol_act;\n    }\n    }\n    a = b;  fa = fb;\t\t\t/* Save the previous approx.\t*/\n    b += new_step;  fb = f(b);\t/* Do step to a new approxim.\t*/\n    if( (fb > 0 && fc > 0) || (fb < 0 && fc < 0) )\n    {                 \t\t\t/* Adjust c for it to have a sign*/\n    c = a;  fc = fa;                  /* opposite to that of b\t*/\n    }\n  }\n}\n",
    "created" : 1474764106042.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1468162877",
    "id" : "9409D710",
    "lastKnownWriteTime" : 1479305867,
    "path" : "~/Dropbox/1- Program/PAFit/PAFit/src/Cpp_code.cpp",
    "project_path" : "src/Cpp_code.cpp",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "cpp"
}